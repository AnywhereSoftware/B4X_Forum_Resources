<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<root>
    <doclet-version-NOT-library-version>1.00</doclet-version-NOT-library-version>
    <class>
        <name>B4R::Wemos_LegacyD1_Pins</name>
        <shortname>Wemos_LegacyD1_Pins</shortname>
        <comment>Pins constants for Wemos D1 Legacy boards (not R2).</comment>
        <field>
            <name DesignerName="D0">D0</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D1">D1</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D2">D2</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D3">D3</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D4">D4</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D5">D5</name>
            <returntype>Byte</returntype>
			<comment>D5 and D13 are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D6">D6</name>
            <returntype>Byte</returntype>
			<comment>D6 and D12 are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D7">D7</name>
            <returntype>Byte</returntype>
			<comment>D7 and D11 are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D8">D8</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D9">D9</name>
            <returntype>Byte</returntype>
			<comment>D9, LED and RX are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D10">D10</name>
            <returntype>Byte</returntype>
			<comment>D10 and TX are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D11">D11</name>
            <returntype>Byte</returntype>
			<comment>D7 and D11 are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D12">D12</name>
            <returntype>Byte</returntype>
			<comment>D6 and D12 are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D13">D13</name>
            <returntype>Byte</returntype>
			<comment>D5 and D13 are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="D14">D14</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D15">D15</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="RX">RX</name>
            <returntype>Byte</returntype>
			<comment>RX, LED and D9 are the same physical I/O pin. RX pin can be also used for general I/O. </comment>
        </field>
        <field>
            <name DesignerName="TX">TX</name>
            <returntype>Byte</returntype>
			<comment>TX and D10 are the same physical I/O pin. TX pin can be also used for general I/O. </comment>
        </field>
        <field>
            <name DesignerName="LED">LED</name>
            <returntype>Byte</returntype>
			<comment>Built in LED. RX, LED and D9 are the same physical I/O pin.</comment>
        </field>
        <field>
            <name DesignerName="A0">A0</name>
            <returntype>Byte</returntype>
			<comment>Analog Input only. Use AnalogRead function (range 0 to 1024)</comment>
        </field>
	</class>
    <class>
        <name>B4R::NodeMCU_ESP12_pins</name>
        <shortname>NodeMCU_ESP12_pins</shortname>
        <comment>Pins constants for NodeMCU ESP-12 boards.</comment>
        <field>
            <name DesignerName="D0">D0</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D1">D1</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D2">D2</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D3">D3</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D4">D4</name>
            <returntype>Byte</returntype>
			<comment>D4 and LED2 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="D5">D5</name>
            <returntype>Byte</returntype>
			<comment>D5 and LED1 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="D6">D6</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D7">D7</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D8">D8</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="RX">RX</name>
            <returntype>Byte</returntype>
			<comment>RX pin can be also used for general I/O.</comment>
        </field>
        <field>
            <name DesignerName="TX">TX</name>
            <returntype>Byte</returntype>
			<comment>TX pin can be also used for general I/O.</comment>
        </field>
        <field>
            <name DesignerName="LED1">LED1</name>
            <returntype>Byte</returntype>
			<comment>Built in LED. LED1 and D5 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="LED2">LED2</name>
            <returntype>Byte</returntype>
			<comment>Built in LED (on Wifi module). LED2 and D4 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="SD2">SD2</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="SD3">SD3</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="SPI_CLK">SPI_CLK</name>
            <returntype>Byte</returntype>
			<comment>SPI_CLK, LED1 and D5 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="SPI_MISO">SPI_MISO</name>
            <returntype>Byte</returntype>
			<comment>SPI_MISO and D6 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="SPI_MOSI">SPI_MOSI</name>
            <returntype>Byte</returntype>
 			<comment>SPI_MOSI and D7 are the same physical I/O.</comment>
		</field>
        <field>
            <name DesignerName="SPI_CS">SPI_CS</name>
            <returntype>Byte</returntype>
 			<comment>SPI_CS and D8 are the same physical I/O.</comment>
		</field>
        <field>
            <name DesignerName="A0">A0</name>
            <returntype>Byte</returntype>
			<comment>Analog Input only. Use AnalogRead function (range 0 to 1024)</comment>
        </field>
    </class>
    <class>
        <name>B4R::Wemos_D1_R2_Pins</name>
        <shortname>Wemos_D1_R2_Pins</shortname>
        <comment>Pins constants for WeMos D1 R2 boards. (also WIFI-D1 board)</comment>
        <field>
            <name DesignerName="D0">D0</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D1">D1</name>
            <returntype>Byte</returntype>
			<comment>D1 and SCL are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="D2">D2</name>
            <returntype>Byte</returntype>
			<comment>D2 and SDA are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="D3">D3</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D4">D4</name>
            <returntype>Byte</returntype>
			<comment>D4 and LED2 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="D5">D5</name>
            <returntype>Byte</returntype>
			<comment>D5 and LED1 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="D6">D6</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D7">D7</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="D8">D8</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="RX">RX</name>
            <returntype>Byte</returntype>
			<comment>RX pin can be also used for general I/O.</comment>
        </field>
        <field>
            <name DesignerName="TX">TX</name>
            <returntype>Byte</returntype>
			<comment>TX pin can be also used for general I/O.</comment>
        </field>
        <field>
            <name DesignerName="LED1">LED1</name>
            <returntype>Byte</returntype>
			<comment>Built in LED. LED1 and D5 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="LED2">LED2</name>
            <returntype>Byte</returntype>
			<comment>Built in LED (on Wifi module). LED2 and D4 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="SD2">SD2</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="SD3">SD3</name>
            <returntype>Byte</returntype>
        </field>
        <field>
            <name DesignerName="SDA">SDA</name>
            <returntype>Byte</returntype>
			<comment>D2 and SDA are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="SCL">SCL</name>
            <returntype>Byte</returntype>
			<comment>D1 and SCL are the same physical I/O.</comment>
        </field>
         <field>
            <name DesignerName="SPI_CLK">SPI_CLK</name>
            <returntype>Byte</returntype>
			<comment>SPI_CLK, LED1 and D5 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="SPI_MISO">SPI_MISO</name>
            <returntype>Byte</returntype>
			<comment>SPI_MISO and D6 are the same physical I/O.</comment>
        </field>
        <field>
            <name DesignerName="SPI_MOSI">SPI_MOSI</name>
            <returntype>Byte</returntype>
 			<comment>SPI_MOSI and D7 are the same physical I/O.</comment>
		</field>
        <field>
            <name DesignerName="SPI_CS">SPI_CS</name>
            <returntype>Byte</returntype>
 			<comment>SPI_CS and D8 are the same physical I/O.</comment>
		</field>
 		<field>
            <name DesignerName="A0">A0</name>
            <returntype>Byte</returntype>
			<comment>Analog Input only. Use AnalogRead function (range 0 to 1024)</comment>
        </field>
    </class>
    <class>
        <name>B4R::B4RESP8266extras</name>
        <shortname>ESP8266extras</shortname>
        <method>
            <name DesignerName="Restart">Restart</name>
            <returntype>B4R::void</returntype>
        </method>
		<method>
            <name DesignerName="UniqueID">UniqueID</name>
            <returntype>ulong</returntype>
			<comment>A Unique constant value that can be used to
identify this individual ESP chip.

ie. if same program loaded into two ESP chips, then UniqueID is a different value for each ESP chip.

You could code the value into your program and test for it to prevent
the program being copied/moved to another ESP part.

Note: It is created from the last 3 bytes of the MAC address for this ESP chip.</comment>
        </method>
        <method>
            <name DesignerName="FlashChipId">FlashChipId</name>
            <returntype>ulong</returntype>
			<comment>Identity the type of Flash Chip.
(like a part number)</comment>
        </method>
        <method>
            <name DesignerName="FlashChipSize">FlashChipSize</name>
            <returntype>ulong</returntype>
			<comment>Size of Flash Chip.</comment>
        </method>
        <method>
            <name DesignerName="CpuFreqMHz">CpuFreqMHz</name>
            <returntype>byte</returntype>
			<comment>Speed of CPU Chip (in Mega Hz)</comment>
        </method>
        <method>
            <name DesignerName="FlashChipSpeed">FlashChipSpeed</name>
            <returntype>ulong</returntype>
			<comment>Speed of Flash Chip (in Hz)</comment>
        </method>
        <method>
            <name DesignerName="CpuCycleCount">CpuCycleCount</name>
            <returntype>ulong</returntype>
			<comment>CPU instruction cycle count since start-up.

This is useful for accurate timing of very short actions like Bit banging.</comment>
        </method>
        <method>
            <name DesignerName="FreeHeapSpace">FreeHeapSpace</name>
            <returntype>ulong</returntype>
			<comment>Returns the Available Heap Space.</comment>
        </method>
        <method>
            <name DesignerName="SketchSize">SketchSize</name>
            <returntype>ulong</returntype>
			<comment>Size of this program.</comment>
        </method>
        <method>
            <name DesignerName="FreeSketchSpace">FreeSketchSpace</name>
            <returntype>ulong</returntype>
			<comment>Amount of unused program space remaining.</comment>
        </method>
        <method>
            <name DesignerName="Vcc">Vcc</name>
            <returntype>ulong</returntype>
			<comment>Measure VCC supply voltage.
			
ESP needs to reconfigure ADC at start-up in order for this feature to be available. 
			
Add the following line To the top of your sketch to use this Vcc function:  
	ADC_MODE(ADC_VCC);
				
TOUT pin has To be disconnected in this mode.

Note, that by default the ADC is configured To read from TOUT pin using analogRead(A0), so the Vcc value is Not Available.
</comment>
        </method>
		
		<field>
            <name DesignerName="WAKE_RF_DEFAULT">WAKE_RF_DEFAULT</name>
            <returntype>int</returntype>
        </field>
		<field>
            <name DesignerName="WAKE_RFCAL">WAKE_RFCAL</name>
            <returntype>int</returntype>
        </field>
		<field>
            <name DesignerName="WAKE_NO_RFCAL">WAKE_NO_RFCAL</name>
            <returntype>int</returntype>
        </field>
		<field>
            <name DesignerName="WAKE_RF_DISABLED">WAKE_RF_DISABLED</name>
            <returntype>int</returntype>
        </field>


		<field>
            <name DesignerName="WIFI_MODE_OFF">WIFI_MODE_OFF</name>
            <returntype>Byte</returntype>
        </field>
		<field>
            <name DesignerName="WIFI_MODE_AP">WIFI_MODE_AP</name>
            <returntype>Byte</returntype>
        </field>
		<field>
            <name DesignerName="WIFI_MODE_STA">WIFI_MODE_STA</name>
            <returntype>Byte</returntype>
        </field>
		<field>
            <name DesignerName="WIFI_MODE_AP_STA">WIFI_MODE_AP_STA</name>
            <returntype>Byte</returntype>
        </field>

		
		<method>
            <name DesignerName="DeepSleep">DeepSleep</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>MicroSeconds</name>
                <type>ulong</type>
            </parameter>
            <parameter>
                <name>WakeMode</name>
                <type>int</type>
            </parameter>
			<comment>Put the ESP into a deep sleep to reduce power consumption.

	MicroSeconds .. wake-up after this time period has elapsed (in usec)

	WakeMode .. use one of these modes
			WAKE_RF_DEFAULT,
			WAKE_RFCAL,
			WAKE_NO_RFCAL,
			WAKE_RF_DISABLED.
Note: 
	GPIO16 needs to be tied to RST to wake from deepSleep.
		I also read that GPIO 0 and 2 pins should be pulled-up to Vcc with say 4K7 resistor to make wake up reliable. I haven't needed this.
</comment>
        </method>

		<method>
            <name DesignerName="GetAPMacAddress">GetAPMacAddress</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>Mac</name>
                <type>byte[]</type>
            </parameter>
			<comment>Read the connected AP's Unique MAC address.
			
Fills the Byte array (Mac) with the 6 byte MAC address.</comment>
        </method>
		<method>
            <name DesignerName="GetMacAddress">GetMacAddress</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>Mac</name>
                <type>byte[]</type>
            </parameter>
			<comment>Read the Wifi device's Unique MAC address.
			
Fills the Byte array (Mac) with the 6 byte MAC address.</comment>
        </method>
		<method>
            <name DesignerName="ResetReasonMessage">ResetReasonMessage</name>
            <returntype>String</returntype>
			<comment>Reason for Last Reset (as text message)</comment>
        </method>
		<method>
            <name DesignerName="ResetReason">ResetReason</name>
            <returntype>ulong</returntype>
			<comment>Reason for Last Reset.

Returns:
	REASON_DEFAULT_RST
	REASON_WDT_RST
	REASON_EXCEPTION_RST
	REASON_SOFT_WDT_RST
	REASON_SOFT_RESTART
	REASON_DEEP_SLEEP_AWAKE
	REASON_EXT_SYS_RST</comment>
        </method>

		<field>
            <name DesignerName="REASON_DEFAULT_RST">REASON_DEFAULT_RST</name>
            <returntype>ulong</returntype>
        </field>
		<field>
            <name DesignerName="REASON_WDT_RST">REASON_WDT_RST</name>
            <returntype>ulong</returntype>
        </field>
		<field>
            <name DesignerName="REASON_EXCEPTION_RST">REASON_EXCEPTION_RST</name>
            <returntype>ulong</returntype>
        </field>
		<field>
            <name DesignerName="REASON_SOFT_WDT_RST">REASON_SOFT_WDT_RST</name>
            <returntype>ulong</returntype>
        </field>
		<field>
            <name DesignerName="REASON_SOFT_RESTART">REASON_SOFT_RESTART</name>
            <returntype>ulong</returntype>
        </field>
		<field>
            <name DesignerName="REASON_DEEP_SLEEP_AWAKE">REASON_DEEP_SLEEP_AWAKE</name>
            <returntype>ulong</returntype>
        </field>
		<field>
            <name DesignerName="REASON_EXT_SYS_RST">REASON_EXT_SYS_RST</name>
            <returntype>ulong</returntype>
        </field>

		<method>
            <name DesignerName="ConfigNetwork">ConfigNetwork</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>IP</name>
                <type>byte[]</type>
            </parameter>
            <parameter>
                <name>Gateway</name>
                <type>byte[]</type>
            </parameter>
            <parameter>
                <name>Subnet</name>
                <type>byte[]</type>
            </parameter>
            <parameter>
                <name>Dns1</name>
                <type>byte[]</type>
            </parameter>
            <parameter>
                <name>Dns2</name>
                <type>byte[]</type>
            </parameter>
			<comment>Configure the Network settings for this Wifi Device.

	Each parameter is a 4 byte array containing a
	new required address.

Note: Configuration changes must be made before the Wifi device is used.</comment>
        </method>

		<method>
           <name DesignerName="ConfigAP">ConfigAP</name>
            <returntype>bool</returntype>
            <parameter>
                <name>IP</name>
                <type>string</type>
            </parameter>
            <parameter>
                <name>Gateway</name>
                <type>string</type>
            </parameter>
            <parameter>
                <name>Subnet</name>
                <type>string</type>
            </parameter>
			<comment>Configure the Access-Point settings for this Wifi Device.

	Each parameter is a String containing a new required address.
		eg. "192.168.10.20"

Returns: True = AP was successfully configured.

Note: Configuration changes must be made before the Wifi device is used.</comment>
        </method>

		<method>
            <name DesignerName="GetAPIP">GetAPIP</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>IP</name>
                <type>byte[]</type>
            </parameter>
			<comment>Read the Wifi device's current Access-Point IP address.
Used when running in AP mode. Different to LocalIP.
	
Fills the Byte array (IP) with the 4 byte IP address.

Note: IP must be predeclared as a 4 byte array.  ie Dim IP(4) as byte</comment>
		</method>
		
		<method>
            <name DesignerName="IP2str">IP2str</name>
            <returntype>string</returntype>
            <parameter>
                <name>IP</name>
                <type>byte[]</type>
            </parameter>
			<comment>Returns the 4 byte array containing IP address 
as a String.
			</comment>
		</method>
		
		<method>
            <name DesignerName="str2IP">str2IP</name>
            <returntype>byte[]</returntype>
            <parameter>
                <name>IP</name>
                <type>string</type>
            </parameter>
			<comment>Decodes the IP address provided as a string and
returns it as a 4 byte array containing the IP address.
			</comment>
		</method>

		<method>
           <name DesignerName="Host2IP">Host2IP</name>
            <returntype>bool</returntype>
            <parameter>
                <name>HostName</name>
                <type>string</type>
            </parameter>
            <parameter>
                <name>IPresult</name>
                <type>byte[]</type>
            </parameter>
			<comment>Resolve the given HostName to an IP address.

IPresult .. must be a 4 byte array. The resolved IP address will be written into it.

Returns: True = Successfully resolved

	Note: You can also use function IsBadIP to test if the IPresult
		is not valid.  ie. IP 0.0.0.0
			</comment>
        </method>

		<method>
           <name DesignerName="IsBadIP">IsBadIP</name>
            <returntype>bool</returntype>
            <parameter>
                <name>IP</name>
                <type>byte[]</type>
            </parameter>
			<comment>Test the IP address to determine if it is valid or not.

IP .. is a 4 byte array containing the IP address to be tested.
	
Returns: TRUE .. if IP address = "0.0.0.0"</comment>
        </method>

		<method>
           <name DesignerName="GetInternetIP">GetInternetIP</name>
            <returntype>int</returntype>
            <parameter>
                <name>IPresult</name>
                <type>byte[]</type>
            </parameter>
			<comment>Get the current Internet IP address for this internet connection.

Uses the internet server/api "api.ipify.org" to analyse your IP.

	IPresult .. must be a 4 byte array.
		It will be filled with the current internet IP address.
	
	Possible returned values:
			0 .. successfully obtained the internet IP
			1 .. IP was not valid. ie. "0.0.0.0"
			2 .. Wifi not connected
			3 .. Server/api not found
			4 .. invalid response from server/api

Notes: This function is BLOCKING. As such it may take a few seconds to return.</comment>
        </method>

		<method>
            <name DesignerName="ConnectWPS">ConnectWPS</name>
            <comment>Connect to a secure network via WPS. Returns True if successful.
			
Note: You need to activate WPS mode on your AP/router (press it's WPS button)
	before executing the ConnectWPS function.
	Can take several seconds to connect.</comment>
            <returntype>bool</returntype>
        </method>

		<method>
            <name DesignerName="ConnectWPS2">ConnectWPS2</name>
            <parameter>
                <name>EEPROM_Position</name>
                <type>UInt</type>
            </parameter>
            <comment>Connect to a secure network via WPS and store the login info in the EEPROM.
The next ConnectWPS2 attempt will use the stored login info to do a fast Reconnect without the need for another WPS.
If the fast Reconnect attempt fails, then a new WPS connection process will be started.

	EEPROM_Position .. 0 to 989, location of login info, in permanent EEPROM memory.

	Returns: True if successful.
			
Note: The stored login info uses 34 bytes in the EEPROM starting
	at EEPROM_Position.</comment>
            <returntype>bool</returntype>
        </method>

		<method>
            <name DesignerName="SSID">SSID</name>
            <returntype>String</returntype>
			<comment>Current Wifi SSID</comment>
        </method>

		<method>
            <name DesignerName="GetLocalIP">GetLocalIP</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>IP</name>
                <type>byte[]</type>
            </parameter>
			<comment>Read the current Local IP address.
	
Fills the Byte array (IP) with the 4 byte IP address.

Note: IP must be predeclared as a 4 byte array.  ie Dim IP(4) as byte</comment>
		</method>

		<method>
            <name DesignerName="GetSubnetMask">GetSubnetMask</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>Subnet</name>
                <type>byte[]</type>
            </parameter>
			<comment>Read the current Subnet Mask for this network.
	
Fills the Byte array (Subnet) with the 4 byte subnet mask.

Note: IP must be predeclared as a 4 byte array.  ie Dim Subnet(4) as byte</comment>
		</method>

		<method>
            <name DesignerName="GetGatwayIP">GetGatewayIP</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>Gateway</name>
                <type>byte[]</type>
            </parameter>
			<comment>Read the current Gateway IP for this network.

Fills the Byte array (Gateway) with the 4 byte subnet mask.

Note: IP must be predeclared as a 4 byte array.  ie Dim Gateway(4) as byte</comment>
		</method>

		<method>
            <name DesignerName="SetChannel">SetChannel</name>
            <returntype>bool</returntype>
            <parameter>
                <name>Channel</name>
                <type>ulong</type>
            </parameter>
			<comment>Set the Channel of the Wifi.
			
	Channel .. 1 to 13
	
	Returns TRUE .. if successful
	
Note: Set Channel before starting ESP as Access Point.</comment>
		</method>

		<method>
            <name DesignerName="GetChannel">GetChannel</name>
            <returntype>ulong</returntype>
			<comment>Get the current Channel of the Wifi.</comment>
		</method>

		<method>
            <name DesignerName="SetPower">SetPower</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>dBm</name>
                <type>byte</type>
            </parameter>
			<comment>Set the Wifi output power level.
			
     dBm ... min(0), max(21)

     Note: dBm=21 actually uses 20.5dBm</comment>
		</method>

		<method>
            <name DesignerName="PrintWifiDetails">PrintWifiDetails</name>
            <returntype>B4R::void</returntype>
			<comment>Print current WiFi settings to the Log.
It actually calls the function
   ESP8266WiFiClass::printDiag
in the source file "ESP8266Wifi.h" and directs the output data to the B4R log.
</comment>
		</method>

		<method>
            <name DesignerName="SetWifiMode">SetWifiMode</name>
            <returntype>B4R::void</returntype>
            <parameter>
                <name>WifiMode</name>
                <type>byte</type>
            </parameter>
			<comment>Set the current Wifi Mode of the Wifi module.
Must use one of these values only:
	WIFI_MODE_OFF
	WIFI_MODE_AP
	WIFI_MODE_STA
	WIFI_MODE_AP_STA
			</comment>
		</method>

		<method>
            <name DesignerName="AnalogWriteRange">AnalogWriteRange</name>
            <comment>Allows you to change the PWM range of AnalogWrite.
Default is a range from 0 to 1023
Example: &lt;code&gt;
Dim Esp As ESP8266
Esp.AnalogWriteRange(255)
&lt;/code&gt;
			</comment>
            <parameter>
                <name>Range</name>
                <type>Uint</type>
            </parameter>
        </method>
        <method>
            <name DesignerName="AnalogWriteFreq">AnalogWriteFreq</name>
            <comment>Allows you to change the PWM frequency of AnalogWrite.
PWM frequency is 1kHz by default.
Example: &lt;code&gt;
Dim Esp As ESP8266
Esp.AnalogWriteFreq(500)
&lt;/code&gt;
			</comment>
            <parameter>
                <name>Freq</name>
                <type>Uint</type>
            </parameter>
        </method>

		<method>
            <name DesignerName="SerialSwap">SerialSwap</name>
            <comment>Swap the Serial port I/O. 
Serial, currently uses UART0, which is mapped to pins GPIO1 (TX) and GPIO3 (RX).
Serial may be remapped to GPIO15 (TX) and GPIO13 (RX) by calling SerialSwap.
Calling SerialSwap again maps UART0 back to GPIO1 and GPIO3.
			</comment>
        </method>

	</class>
    <version>1.07</version>
</root>
