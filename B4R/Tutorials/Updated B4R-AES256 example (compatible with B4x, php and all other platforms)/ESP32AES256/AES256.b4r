Build1=Default,B4RDev
Group=Default Group
Library1=rcore
Library2=rrandomaccessfile
NumberOfFiles=0
NumberOfLibraries=2
NumberOfModules=0
Version=3.71
@EndOfDesignText@

#Region Project Attributes
	#AutoFlushLogs: True
	#CheckArrayBounds: True
	#StackBufferSize: 3000
#End Region

Sub Process_Globals
    Public Serial1 As Serial
	Public bc As ByteConverter
	
	'AES
	Public plaintext_buffer(256) As Byte 'Must be a multiple of 16 as PKCSNoPadding is used
	Public aesencrypted_buffer(256) As  Byte 'the encrypted message
	
	Public iv(16) As Byte 'initialization vector. Must be the same for enc- and decryption
	Public salt(32) As Byte 'Salt 
	Public pw(32) As  Byte = "Secret"'pw/key (will be hashed to 32 bytes)
	
	Public encrypted_len,plaintext_len As Int 'encrypted length = padded plaintext-length 
	
	
		
End Sub

Private Sub AppStart
    Serial1.Initialize(115200)
	Log("AppStart")
	
	Dim mess As String="B4REncryptedLongMessage1234567890"
	Dim MessagePaddedWithSaltAndIV() As Byte =Encrypt(Pad(mess,16,1,0))
		
	Dim DecryptedMessage() As Byte =DecryptMessage(MessagePaddedWithSaltAndIV)
	Log("decrypted: ", DecryptedMessage)
	
End Sub

#if C
//Vars used for both methods
#include <mbedtls/aes.h>
#include "mbedtls/md.h"

char ivc[16];
#end if



Private Sub DecryptMessage(enc() As Byte) As Byte()
	SplitSaltIDIVMessage(enc)
	
	RunNative("Decrypt", Null)
	Dim decmess(encrypted_len) As Byte
	bc.ArrayCopy2(plaintext_buffer,0,decmess,0,encrypted_len)
	
	Dim UnpaddedMess() As Byte=Unpad(decmess)
	
	Return UnpaddedMess
	
End Sub

Private Sub SplitSaltIDIVMessage (IDIvMessage() As Byte)
	
	bc.ArrayCopy2(IDIvMessage,0,salt,0,salt.Length)
	bc.ArrayCopy2(IDIvMessage,salt.Length,iv,0,iv.Length)
	
	Dim Mess(IDIvMessage.Length-salt.Length-iv.Length) As Byte
	'Init Mess
	For i=0 To Mess.Length-1
		Mess(i)=0
	Next
	For I=0 To aesencrypted_buffer.Length-1
		aesencrypted_buffer(I)=0
	Next
	For I=0 To plaintext_buffer.Length-1
		plaintext_buffer(I)=0
	Next
	bc.ArrayCopy2(IDIvMessage,salt.Length+iv.Length,Mess,0,IDIvMessage.Length-salt.Length-iv.Length)
	bc.ArrayCopy2(Mess,0,aesencrypted_buffer,0,Mess.Length)
	encrypted_len=Mess.Length
End Sub


#if c



void Decrypt (B4R::Object* o) {

//printf("Decrypt started \n");

char *pw = (char*)b4r_main::_pw->data;
char *ivc = (char*)b4r_main::_iv->data;

//256Hash the pw (32 Bytes)
  byte shaResult[32];
  mbedtls_md_context_t hash;
  mbedtls_md_type_t md_type = MBEDTLS_MD_SHA256;
  const size_t pwLength = strlen(pw);         
  mbedtls_md_init(&hash);
  mbedtls_md_setup(&hash, mbedtls_md_info_from_type(md_type), 0);
  mbedtls_md_starts(&hash);
  mbedtls_md_update(&hash, (const unsigned char *) pw, pwLength);
  mbedtls_md_finish(&hash, shaResult);
  mbedtls_md_free(&hash);
  uint8_t key[32];
  memcpy(key, shaResult, 32);  

//Set iv
	uint8_t ivu[16];
	int i;
	for( i = 0; i < 16; i++ )
	{
	ivu[i]=ivc[i];
	} 

esp_aes_context ctx;
esp_aes_init( &ctx );
esp_aes_setkey( &ctx, key, 256 );
esp_aes_crypt_cbc( &ctx, ESP_AES_DECRYPT, b4r_main::_encrypted_len, ivu, (uint8_t*)b4r_main::_aesencrypted_buffer->data, (uint8_t*)b4r_main::_plaintext_buffer->data );
esp_aes_free( &ctx );

}

#End If


Sub Pad (mess() As Byte, PadTo As Int,PadMode As Int,PadValue As Object) As Byte()
	Dim MessLength As Int = mess.Length
	Dim PaddedLength As Int
	PaddedLength = MessLength-MessLength Mod PadTo + PadTo
	
	Dim PaddedMess(PaddedLength) As Byte
	bc.ArrayCopy2(mess,0,PaddedMess,0,mess.Length)
	For i=mess.Length To PaddedLength-2
		Select PadMode
			Case 1
				PaddedMess(i)=Rnd(0,256)
			Case 2
				PaddedMess(i)=PadValue
			Case 3
				PaddedMess(i)=PaddedLength-MessLength
		End Select
	Next
	PaddedMess(PaddedLength-1)=PaddedLength-MessLength
	Return PaddedMess
End Sub

Sub Unpad (PaddedMess() As Byte) As Byte()
	Dim OrigMess(PaddedMess.Length-PaddedMess(PaddedMess.Length-1)) As Byte
	bc.ArrayCopy2(PaddedMess,0,OrigMess,0,OrigMess.Length)
	Return OrigMess
End Sub


Private Sub Encrypt (Messtext() As Byte) As Byte()
	
	plaintext_len=Messtext.Length
	
	
	'Reset data
	For I=0 To aesencrypted_buffer.Length-1
		aesencrypted_buffer(I)=0
		plaintext_buffer(I)=0
	Next
		
	'Set Plaintext
	bc.ArrayCopy2(Messtext,0,plaintext_buffer,0,Messtext.Length)
	
	'Generate and set IV
	bc.ArrayCopy(GenerateRandomBytes(16),iv)
	
	'Generate and set Salt
	bc.ArrayCopy(GenerateRandomBytes(32),salt)
		
	RunNative("Encrypt", Null)
	Dim encryptedmessage(Messtext.Length) As Byte
	bc.ArrayCopy2(aesencrypted_buffer,0,encryptedmessage,0,Messtext.Length)
	
	'final message = salt + iv + encrypted message
	Dim mc(salt.Length+iv.Length+plaintext_len) As Byte = JoinBytes(Array(salt,iv,encryptedmessage))
	
	Return mc
	
	
End Sub

#if c
void Encrypt (B4R::Object* o) {

char *pw = (char*)b4r_main::_pw->data;
char *ivc = (char*)b4r_main::_iv->data;


//256Hash the pw (32 Bytes)
  byte shaResult[32];
  mbedtls_md_context_t hash;
  mbedtls_md_type_t md_type = MBEDTLS_MD_SHA256;
  const size_t pwLength = strlen(pw);         
  mbedtls_md_init(&hash);
  mbedtls_md_setup(&hash, mbedtls_md_info_from_type(md_type), 0);
  mbedtls_md_starts(&hash);
  mbedtls_md_update(&hash, (const unsigned char *) pw, pwLength);
  mbedtls_md_finish(&hash, shaResult);
  mbedtls_md_free(&hash);
  uint8_t key[32];
  memcpy(key, shaResult, 32);  
 //***********************************************************************************  
 
//Set iv
	uint8_t ivu[16];
	int i;
	for( i = 0; i < 16; i++ )
	{
	ivu[i]=ivc[i];
	} 

esp_aes_context ctx;
esp_aes_init( &ctx );
esp_aes_setkey( &ctx, key, 256 );
esp_aes_crypt_cbc( &ctx, ESP_AES_ENCRYPT, b4r_main::_plaintext_len, ivu, (uint8_t*)b4r_main::_plaintext_buffer->data, (uint8_t*)b4r_main::_aesencrypted_buffer->data );
esp_aes_free( &ctx );

}
#End If

Sub GenerateRandomBytes(count As Int) As Byte()
	Dim rb(count) As Byte
	For i=0 To count-1
	   rb(i)=Rnd(0,256)
	Next
	
	Return rb
		
End Sub


