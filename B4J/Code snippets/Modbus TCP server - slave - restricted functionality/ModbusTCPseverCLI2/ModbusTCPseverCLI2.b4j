AppType=StandardJava
Build1=Default,b4j.example
Group=Default Group
Library1=jcore
Library2=jnetwork
Library3=jrandomaccessfile
Library4=byteconverter
NumberOfFiles=0
NumberOfLibraries=4
NumberOfModules=0
Version=6.8
@EndOfDesignText@
'Non-UI application (console / server application)
#Region Project Attributes 
	#CommandLineArgs:
	#MergeLibraries: True 
#End Region


'Big fat warning!!
'The network handling should be running in a service when using gui applications!
'The holding register range is 200 registers long.
'No exceptions implemented in reponse messages
'It is ONLY possible to read holding registes (function code 03), a master cannot write to this server - slave




Sub Process_Globals
	Dim AStreams As AsyncStreams
	Dim Server As ServerSocket
	Dim Socket1 As Socket
	
	Dim slaveAddress As Byte = 1 'Slave address 
	Dim HoldReg(201) As Short 'Array with holding registers - 16 bit intergers - signed
								'array's are always zero based, so I add one to count easy, so i don't mind the zero
	Dim RxTransIdent(2) As Byte '2byte array
	Dim RxProtocolIdent(2) As Byte '2 byte array
	Dim RxLength(2) As Byte 'Length of the message, counted from Unit Identifier (slaveAdress is the same) 
	Dim RxUnitIdentifier As Byte
	Dim RxFunctionCode As Byte
	Dim RxFirstAddresRegister(2) As Byte 'First adress register
	Dim RxRange(2) As Byte 'The number of required registers
	
	Dim RequestFirstAddresReg As Short
	Dim RequestRangeReg As Short
	
	

End Sub

Sub AppStart (Args() As String)
	
		'TCP Port 502 is the standard for modbus TCP
		Server.Initialize(502, "Server")
		Server.Listen
		Log("MyIp = " & Server.GetMyIP)
	
	
	'Here an example of some data in the Holding Register array	
	HoldReg(0) = 123
	HoldReg(1) = 111
	HoldReg(2) = 222
	HoldReg(3) = 333
	HoldReg(4) = 444
	HoldReg(5) = 555
	HoldReg(200) = 888
	
		
	
	StartMessageLoop

End Sub


Sub Server_NewConnection (Successful As Boolean, NewSocket As Socket)
	If Successful Then
		Log("Connected" )
		Socket1 = NewSocket
		'Can only use prefix mode if both sides of the connection implement the prefix protocol!!!
		AStreams.Initialize(Socket1.InputStream, Socket1.OutputStream, "AStreams")
		
	Else
		Log(LastException.Message)
	End If
	Server.Listen
End Sub

Sub AStreams_NewData (Buffer() As Byte)
	'NewData has arrived, pass it to the sub
	ProcessRequest(Buffer)
	
End Sub

Sub ProcessRequest(Buffer2() As Byte)
	Try
		
	
	If Buffer2.Length = 12 Then
	
		'Capturing raw buffer data and putting it in memory
		RxTransIdent(0) = Buffer2(0)
		RxTransIdent(1)= Buffer2(1)
		RxProtocolIdent(0)= Buffer2(2)
		RxProtocolIdent(1)= Buffer2(3)
		RxLength(0)= Buffer2(4)
		RxLength(1)= Buffer2(5)
		RxUnitIdentifier= Buffer2(6)
		RxFunctionCode= Buffer2(7)
		RxFirstAddresRegister(0) =  Buffer2(9) '! Byte swapping
		RxFirstAddresRegister(1)= Buffer2(8)
		RxRange(0) = Buffer2(11)'! Byte swapping
		RxRange(1) = Buffer2(10)
	
		End If
				
		'Check Protocol Identifier
		If RxProtocolIdent(0) <> 0 Or RxProtocolIdent(1) <> 0 Then
			Log( "Illegal Protocol Identifier")
			 Return 'exit sub
		End If
		
		'Check Length
		If RxLength(0) <> 0 Or RxLength(1) <> 6 Then
			Log( "Illegal Length")
			Return'exit sub
		End If
		
		'Check FunctionCode
		If RxFunctionCode <> 3  Then		'Only holding registers supported
			Log( "Illegal Function Code")
			Return'exit sub
		End If
		
		'Check FunctionCode
		If RxUnitIdentifier <> slaveAddress  Then
			Log( "Illegal Unique Identifier - or Slave Address Code")
			Return'exit sub
		End If
			
		
		'In the Hold Reg array, all registers are stored as a short value
		'The RequestFirstAddresReg is the value in short where reading starts
		RequestFirstAddresReg =  ByteToShort(RxFirstAddresRegister)
		RequestRangeReg = ByteToShort(RxRange)
		
		'Protection when used asks more then buffer range
		If RequestFirstAddresReg > 201 Then
			Log( "Illegal adress requested")
			Return'exit sub
		End If
		
		'Protection when startadress in is limits, but range is going outside the buffer range
		If (RequestFirstAddresReg + RequestRangeReg) > 201 Then
			Log( "Requested range out of buffer size")
			Return'exit sub
		End If
		
		'For testing only:
		'Log(RequestFirstAddresReg)
		'Log(RequestRangeReg)
		
		'Here starts the real request of the data from the array
		
		Dim ArraySize As Short
		ArraySize = 9 + (RequestRangeReg * 2)
		
		
		'Declare array for sending
		Dim  TxBuffer (ArraySize)   As Byte
		
		'Answer with same transaction ID
		TxBuffer(0) = RxTransIdent(0)
		TxBuffer(1) = RxTransIdent(1)
		'Protocol ID is also zero
		TxBuffer(2) = 0
		TxBuffer(3) = 0
		
		'Send the lenght that follows
		Dim bmem(2) As Byte = ShortToByte(RequestRangeReg * 2 + 3)
		TxBuffer(4) = bmem(1)
		TxBuffer(5) = bmem(0)
		
		'The device adress or Unit Identifier
		TxBuffer(6) = slaveAddress
		
		'Only holding registers supported
		TxBuffer(7) = 3
		
		'Length of requested registers, in bytes, so multiplied by 2
		'We need to put is first in a byte array, as a short conversion contains two bytes
		Dim bmem2(2) As Byte = ShortToByte((RequestRangeReg*2))
		TxBuffer(8) = bmem2(0)
		
		
		
		'For every holding register to bo read, put it in the Tx buffer on the right place		
		Dim HoldRegAsByteArr(2) As Byte
		For i = 0 To (RequestRangeReg-1) Step 1
			
			HoldRegAsByteArr =ShortToByte(HoldReg((RequestFirstAddresReg -1)  + i + 1 ))
			
			TxBuffer(9+(i*2)) = HoldRegAsByteArr(1) '!Swap bytes, MSB first
			TxBuffer(10+(i*2)) = HoldRegAsByteArr(0)
			
		Next
		

		'Send response
		SendResponse(TxBuffer)
			
		
	Catch
		Log(LastException)
	End Try
	
End Sub

Sub SendResponse(SendBuffer ()As Byte)
	
	If AStreams.IsInitialized = False Then Return
	
	Dim buffer() As Byte
	buffer = SendBuffer'myText.GetBytes("UTF8")
	AStreams.Write(buffer)
	
	Log("Sending response" )
	
	
End Sub

Sub AStreams_Error
	Log(LastException.Message)
	Log("AStreams_Error")
End Sub

Sub AStreams_Terminated
	Log("AStreams_Terminated")
	
	
End Sub


'Return true to allow the default exceptions handler to handle the uncaught exception.
Sub Application_Error (Error As Exception, StackTrace As String) As Boolean
	Return True
End Sub


Sub ByteToShort(ByteArray() As Byte) As Short
	
	Dim bc As ByteConverter
	bc.LittleEndian = True
	Dim i As Short = bc.shortsFromBytes(ByteArray)(0)
		
	Return  i
	
End Sub

Sub ShortToByte(ShortValue As Short) As Byte()
	
	Dim bc As ByteConverter
	bc.LittleEndian = True
	Dim b() As Byte = bc.ShortsToBytes(Array As Short(ShortValue))
		
	Return b
	
End Sub

