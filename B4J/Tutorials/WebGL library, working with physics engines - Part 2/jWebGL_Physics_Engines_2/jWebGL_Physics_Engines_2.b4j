AppType=JavaFX
Build1=Default,b4j.example
File1=Layout1.bjl
File2=Resources.zip
FileGroup1=Default Group
FileGroup2=Default Group
Group=Default Group
Library1=jcore
Library2=jfx
Library3=jxui
Library4=jwebgl
NumberOfFiles=2
NumberOfLibraries=4
NumberOfModules=0
Version=10
@EndOfDesignText@
#Region Project Attributes 
	#MainFormWidth: 300
	#MainFormHeight: 200 
#End Region

Sub Process_Globals
	Private fx As JFX
	Private MainForm As Form
	Private xui As XUI
	Private Button1 As B4XView
	
	Private gl As WebGL
	Private Port As Int = 8888
End Sub

Sub AppStart (Form1 As Form, Args() As String)
	MainForm = Form1
	MainForm.RootPane.LoadLayout("Layout1")
	MainForm.Title = "WebGL Physics Engines 2"
	MainForm.Show
End Sub

Sub Button1_Click
	Button1.Enabled = False
	
	' Set here the path where THREEJS distribution was unzipped.
	' More concurrent projects can run at same time, just use different port for each if you need this.
	gl.Initialize(Me, "WebGL", "WebGL_Physics_Engines_2", "GMT+1", File.DirData("B4XWebGL"), Port)

	Dim files As List
	files.Initialize
	files.AddAll(Array As String("textures/cube/skybox/px.jpg", _
										  "textures/cube/skybox/nx.jpg", _
										  "textures/cube/skybox/py.jpg", _
										  "textures/cube/skybox/ny.jpg", _
										  "textures/cube/skybox/pz.jpg", _
										  "textures/cube/skybox/nz.jpg", _
										  "jsm/physics/cannon-es.js", _
										  "jsm/physics/cannon-es-debugger.js", _
										  "textures/grid.png", _
										  "textures/equirectangular/equirectangular.png", _
										  "models/gltf/right-hand-bent.glb", _
										  "models/obj/bowl2.obj"))	
	
	Wait For (gl.CopyResourcesFromZipFile(files, "Resources.zip", 8192)) Complete (Success As Boolean)
	If Success Then
		LogColor("RESOURCES DONE", xui.Color_Blue)
	Else
		LogColor("SOMETHING WENT WRONG WHILE GET RESOURCES", xui.Color_Red)
	End If

	'''''''''''''
	
	Wait For (gl.GetEngine) Complete (Success As Boolean)
	If Success Then
'		gl.SetLocalServer(True)

      ' UNCOMMENT JUST ONE AT TIME
		gl.StartEngine3(Scene1)
'		gl.StartEngine3(Scene2)
		
		gl.Update
	Else
		LogError("Unable to initialize WebGL Library")
	End If
End Sub

'///////////// WebGL Library Events ////////////

' Called if error occours
Sub WebGL_Error(Error As String)
	LogColor(Error, xui.Color_Red)
End Sub

 ' IMPORTANT NOTE: _ReadyToCode event is never fired when we use StartEngine3 and pass a full html string.
 '                 When we load a full HTML + JS code, we cannot use Inject command or other similar commands
 '                 that inject code. Your final code is all contained in the passed full HTML string.

' Called just one time when the scene is updated
Private Sub WebGL_Updated(Url As String)
	Log(" ") : LogColor("Server static folder: " & gl.MainFolder, xui.Color_Magenta)
	Log(" ") : Log("To access the scene:")
	LogColor(Url, xui.Color_Magenta)
	Log("To access the library main page:")
	LogColor(gl.ServerMainPage, xui.Color_Magenta) : Log(" ")
	
	' ' To avoid log truncation we can print it line by line
'	Dim lines() As String = Regex.Split(CRLF, gl.HtmlStringDebug)
'	For Each line As String In lines
'		LogColor(line, xui.Color_Blue)
'	Next
	
'	LogColor(gl.HtmlString, xui.Color_Blue) : Log(" ")  ' Show the final html string
'	LogColor(gl.HtmlStringDebug, xui.Color_Blue) : Log(" ")  ' Show the final html string in debug mode with line numbers. With this we can track JavaScript console errors.
End Sub

' Called when there are library server logs
Private Sub WebGL_ServerLog(Text As String)
	If Text.Contains(".html") Or Text.ToLowerCase.Contains("mainpage") Then
		If Text.Contains("[200]") Then  ' File found
			LogColor(Text, xui.Color_Magenta)
		Else If Text.Contains("[304]") Then  ' Cached
			LogColor(Text, 0xFFFF7F00)
		Else If Text.Contains("[404]") Then  ' File not found
			LogColor(Text, xui.Color_Red)
		End If
	Else
		If Text.Contains("[200]") Then  ' File found
			LogColor(Text, xui.Color_Blue)
		Else If Text.Contains("[304]") Then  ' Cached
			LogColor(Text, 0xFFFF7F00)
		Else If Text.Contains("[404]") Then  ' File not found
			LogColor(Text, xui.Color_Red)
		End If
	End If
End Sub

'/////////////////////////// SCENES ///////////////////////////////

' Destructor
Sub Scene1 As String
	
	Dim html As String = $"<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Convex object breaking example</title>
		<!-- This is important to get the correct canvas size on mobile devices -->
		<meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'/>
		<style>
			body {
				font-family: Monospace;
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				padding: 10px;
				width: 100%;
				text-align: center;
			}
		</style>
	</head>

	<body>
	   <div id="info">Physics threejs demo with convex objects breaking in real time<br />Press mouse to throw objects and move, zoom, pan the camera.</div>
      <div id="container"></div>

		<script src="jsm/libs/ammo.wasm.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>
      
	<script type="module">
	
		import * as THREE from 'three'
      import Stats from 'three/addons/libs/stats.module.js'
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { ConvexObjectBreaker } from 'three/addons/misc/ConvexObjectBreaker.js';
		import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js'

		// -------------- Global variables --------------
		
		let container, stats, camera, controls, scene, renderer, textureLoader;
		
		const gui = new GUI( { width: 200 } );
		const clock = new THREE.Clock();

		const mouseCoords = new THREE.Vector2();
		const raycaster = new THREE.Raycaster();
      const ballMaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff, shininess: 180 } );

		// -------------- Physics variables --------------
		
		var gravity = 2.0;
		
		gui.add({Gravity: gravity}, 'Gravity', -2, 9.81, 0.1).onChange( (value) => { 
			gravity = value; 
			console.log('Gravity changed by GUI: ' + gravity)
			physicsWorld.setGravity( new Ammo.btVector3( 0, - gravity, 0 ) );  // Set the gravity
		});	
		
		let collisionConfiguration, dispatcher, broadphase, solver, physicsWorld;
		const margin = 0.01;

		const convexBreaker = new ConvexObjectBreaker();

		const rigidBodies = [];	 // Rigid bodies include all movable objects

		const pos = new THREE.Vector3();
		const quat = new THREE.Quaternion();
		let transformAux1;
		let tempBtVec3_1;

		const objectsToRemove = [];

		for ( let i = 0; i < 500; i ++ )  objectsToRemove[ i ] = null;

		let numObjectsToRemove = 0;

		const impactPoint = new THREE.Vector3();
		const impactNormal = new THREE.Vector3();

		// -------------- Main code --------------
		
		Ammo().then( ( AmmoLib ) => {
			Ammo = AmmoLib;
			init();
		} );

		// -------------- Main Functions ---------------
		
		function init() {
			initGraphics();
			initPhysics();
			createObjects();
			initInput();
		}

		function initGraphics() {
			container = document.getElementById( 'container' );

			camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );
         camera.position.set( - 14, 8, 16 );

			const path = 'textures/cube/skybox/';
			const format = '.jpg';
			const envMap = new THREE.CubeTextureLoader().load([
				path + 'px' + format, path + 'nx' + format,
				path + 'py' + format, path + 'ny' + format,
				path + 'pz' + format, path + 'nz' + format,
			]);
			envMap.mapping = THREE.EquirectangunarReflectionMapping;
			envMap.encoding = THREE.sRGBEncoding;

			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xbfd1e5 );
			scene.background = envMap;
			scene.environment = envMap;

			scene.fog = new THREE.Fog(0xcce0ff, 0.1, 300);

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.shadowMap.enabled = true;
			container.appendChild( renderer.domElement );

			controls = new OrbitControls(camera, renderer.domElement);
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.enableDamping = true;
			controls.dampingFactor = 0.02;
			//controls.autoRotate = true;
			//controls.autoRotateSpeed = 0.2;			
			controls.target.set( 0, 1.0, 0 );

			textureLoader = new THREE.TextureLoader();

			const ambientLight = new THREE.AmbientLight( 0xbbbbbb );
			scene.add( ambientLight );

			const light = new THREE.DirectionalLight( 0xffffff, 3 );
			light.position.set( - 10, 18, 5 );
			light.castShadow = true;
			
			const d = 28;
			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;
			light.shadow.camera.near = 2;
			light.shadow.camera.far = 50;

			light.shadow.mapSize.x = 1024;
			light.shadow.mapSize.y = 1024;

			scene.add( light );

			stats = new Stats();
			container.appendChild( stats.domElement );

			window.addEventListener( 'resize', onWindowResize );
		}

		function initPhysics() {	// Physics configuration	
			collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
			dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
			broadphase = new Ammo.btDbvtBroadphase();
			solver = new Ammo.btSequentialImpulseConstraintSolver();
			physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
			
			physicsWorld.setGravity( new Ammo.btVector3( 0, - gravity, 0 ) );  // Set the initial gravity (We can change it later by GUI)

			transformAux1 = new Ammo.btTransform();
			tempBtVec3_1 = new Ammo.btVector3( 0, 0, 0 );
		}

		function createObject( mass, halfExtents, pos, quat, material ) {
			const object = new THREE.Mesh( new THREE.BoxGeometry( halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2 ), material );
			object.position.copy( pos );
			object.quaternion.copy( quat );
			convexBreaker.prepareBreakableObject( object, mass, new THREE.Vector3(), new THREE.Vector3(), true );
			createDebrisFromBreakableObject( object );
		}

		function createObjects() {

			// Ground
			pos.set( 0, - 0.5, 0 );
			quat.set( 0, 0, 0, 1 );
			const ground = createParalellepipedWithPhysics( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
			ground.receiveShadow = true;
			
			textureLoader.load( 'textures/grid.png', function ( texture ) {
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 40, 40 );
				ground.material.map = texture;
				ground.material.needsUpdate = true;
			} );

			// Tower 1
			const towerMass = 1400;
			const towerHalfExtents = new THREE.Vector3( 2, 5, 2 );
			pos.set( - 8, 5, 0 );
			quat.set( 0, 0, 0, 1 );
			createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xB03014 ) );

			// Tower 2
			pos.set( 8, 5, 0 );
			quat.set( 0, 0, 0, 1 );
			createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xB03214 ) );

			//Bridge
			const bridgeMass = 140;
			const bridgeHalfExtents = new THREE.Vector3( 7, 0.2, 1.5 );
			pos.set( 0, 10.2, 0 );
			quat.set( 0, 0, 0, 1 );
			createObject( bridgeMass, bridgeHalfExtents, pos, quat, createMaterial( 0xB3B865 ) );

			// Stones
			const stoneMass = 120;
			const stoneHalfExtents = new THREE.Vector3( 1, 2, 0.15 );
			const numStones = 15;
			quat.set( 0, 0, 0, 1 );		
			for ( let i = 0; i < numStones; i ++ ) {
				pos.set( 0, 2, 20 * ( 0.5 - i / ( numStones + 1 ) ) );
				createObject( stoneMass, stoneHalfExtents, pos, quat, createMaterial( 0xB0B0B0 ) );
			}

			// Mountain
			const mountainMass = 860;
			const mountainHalfExtents = new THREE.Vector3( 4, 5, 4 );
			pos.set( 5, mountainHalfExtents.y * 0.5, - 7 );
			quat.set( 0, 0, 0, 1 );
			const mountainPoints = [];
			mountainPoints.push( new THREE.Vector3( mountainHalfExtents.x, - mountainHalfExtents.y, mountainHalfExtents.z ) );
			mountainPoints.push( new THREE.Vector3( - mountainHalfExtents.x, - mountainHalfExtents.y, mountainHalfExtents.z ) );
			mountainPoints.push( new THREE.Vector3( mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z ) );
			mountainPoints.push( new THREE.Vector3( - mountainHalfExtents.x, - mountainHalfExtents.y, - mountainHalfExtents.z ) );
			mountainPoints.push( new THREE.Vector3( 0, mountainHalfExtents.y, 0 ) );
			const mountain = new THREE.Mesh( new ConvexGeometry( mountainPoints ), createMaterial( 0xB03814 ) );
			mountain.position.copy( pos );
			mountain.quaternion.copy( quat );
			convexBreaker.prepareBreakableObject( mountain, mountainMass, new THREE.Vector3(), new THREE.Vector3(), true );
			createDebrisFromBreakableObject( mountain );
		}

		function createParalellepipedWithPhysics( sx, sy, sz, mass, pos, quat, material ) {
			const object = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );
			const shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
			shape.setMargin( margin );

			createRigidBody( object, shape, mass, pos, quat );
			return object;
		}

		function createDebrisFromBreakableObject( object ) {
			object.castShadow = true;
			object.receiveShadow = true;

			const shape = createConvexHullPhysicsShape( object.geometry.attributes.position.array );
			shape.setMargin( margin );

			const body = createRigidBody( object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity );

			// Set pointer back to the three object only in the debris objects
			const btVecUserData = new Ammo.btVector3( 0, 0, 0 );
			btVecUserData.threeObject = object;
			body.setUserPointer( btVecUserData );
		}

		function removeDebris( object ) {
			scene.remove( object );
			physicsWorld.removeRigidBody( object.userData.physicsBody );
		}

		function createConvexHullPhysicsShape( coords ) {
			const shape = new Ammo.btConvexHullShape();
			for ( let i = 0, il = coords.length; i < il; i += 3 ) {
				tempBtVec3_1.setValue( coords[ i ], coords[ i + 1 ], coords[ i + 2 ] );
				const lastOne = ( i >= ( il - 3 ) );
				shape.addPoint( tempBtVec3_1, lastOne );
			}
			return shape;
		}

		function createRigidBody( object, physicsShape, mass, pos, quat, vel, angVel ) {

			if ( pos ) 
			   object.position.copy( pos );
			else 
			   pos = object.position;
			  
			if ( quat )
			   object.quaternion.copy( quat );
			else 
			   quat = object.quaternion;

			const transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
			const motionState = new Ammo.btDefaultMotionState( transform );

			const localInertia = new Ammo.btVector3( 0, 0, 0 );
			physicsShape.calculateLocalInertia( mass, localInertia );

			const rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
			const body = new Ammo.btRigidBody( rbInfo );

			body.setFriction( 0.8 );

			if ( vel )  body.setLinearVelocity( new Ammo.btVector3( vel.x, vel.y, vel.z ) );
			if ( angVel )  body.setAngularVelocity( new Ammo.btVector3( angVel.x, angVel.y, angVel.z ) );

			object.userData.physicsBody = body;
			object.userData.collided = false;

			scene.add( object );

			if ( mass > 0 ) {
				rigidBodies.push( object );		
				body.setActivationState( 4 );	 // Disable deactivation
			}
			physicsWorld.addRigidBody( body );
			return body;
		}

		function createRandomColor() {
			return Math.floor( Math.random() * ( 1 << 24 ) );
		}

		function createMaterial( color ) {
			color = color || createRandomColor();
			return new THREE.MeshPhongMaterial( { color: color } );
		}

		function initInput() {
			window.addEventListener( 'pointerdown', function ( event ) {

				mouseCoords.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouseCoords, camera );

				// Creates a ball and throws it
				const ballMass = 35;
				let ballRadius = 0.8;

				//const ball = new THREE.Mesh( new THREE.SphereGeometry( ballRadius, 10, 6 ), ballMaterial );
				const ball = new THREE.Mesh( new THREE.TorusKnotGeometry( ballRadius-ballRadius/3, ballRadius/5, 64, 16 ), ballMaterial );
				//const ball = new THREE.Mesh( new THREE.TorusGeometry( ballRadius-ballRadius/3, ballRadius/3, 16, 100 ), ballMaterial );
				//const ball = new THREE.Mesh( new THREE.IcosahedronGeometry(ballRadius, 0), ballMaterial );

				ball.castShadow = true;
				ball.receiveShadow = true;
				const ballShape = new Ammo.btSphereShape( ballRadius );
				ballShape.setMargin( margin );
				pos.copy( raycaster.ray.direction );
				pos.add( raycaster.ray.origin );
				quat.set( 0, 0, 0, 1 );
				const ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );

				pos.copy( raycaster.ray.direction );
				pos.multiplyScalar( 24 );
				ballBody.setLinearVelocity( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			} );
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate() {
			render();
			controls.update();
			stats.update();
		}

		function render() {
			const deltaTime = clock.getDelta();
			updatePhysics( deltaTime );
			renderer.render( scene, camera );
		}

		function updatePhysics( deltaTime ) {
	
			physicsWorld.stepSimulation( deltaTime, 10 );	// Step world

			// Update rigid bodies
			for ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {
				const objThree = rigidBodies[ i ];
				const objPhys = objThree.userData.physicsBody;
				const ms = objPhys.getMotionState();
				if ( ms ) {
					ms.getWorldTransform( transformAux1 );
					const p = transformAux1.getOrigin();
					const q = transformAux1.getRotation();
					objThree.position.set( p.x(), p.y(), p.z() );
					objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

					objThree.userData.collided = false;
				}
			}

			for ( let i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) {
				const contactManifold = dispatcher.getManifoldByIndexInternal( i );
				const rb0 = Ammo.castObject( contactManifold.getBody0(), Ammo.btRigidBody );
				const rb1 = Ammo.castObject( contactManifold.getBody1(), Ammo.btRigidBody );

				const threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
				const threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;

				if ( ! threeObject0 && ! threeObject1 ) 	continue;

				const userData0 = threeObject0 ? threeObject0.userData : null;
				const userData1 = threeObject1 ? threeObject1.userData : null;

				const breakable0 = userData0 ? userData0.breakable : false;
				const breakable1 = userData1 ? userData1.breakable : false;

				const collided0 = userData0 ? userData0.collided : false;
				const collided1 = userData1 ? userData1.collided : false;

				if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) 	continue;
			
				let contact = false, maxImpulse = 0;
				for ( let j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) {
					const contactPoint = contactManifold.getContactPoint( j );

					if ( contactPoint.getDistance() < 0 ) {
						contact = true;
						const impulse = contactPoint.getAppliedImpulse();

						if ( impulse > maxImpulse ) {
							maxImpulse = impulse;
							const pos = contactPoint.get_m_positionWorldOnB();
							const normal = contactPoint.get_m_normalWorldOnB();
							impactPoint.set( pos.x(), pos.y(), pos.z() );
							impactNormal.set( normal.x(), normal.y(), normal.z() );
						}
						break;
					}
				}
			
				if ( ! contact ) continue;	 // If no point has contact, abort

				// Subdivision

				const fractureImpulse = 250;

				if ( breakable0 && ! collided0 && maxImpulse > fractureImpulse ) {
					const debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal, 1, 2, 1.5 );

					const numObjects = debris.length;
					for ( let j = 0; j < numObjects; j ++ ) {
						const vel = rb0.getLinearVelocity();
						const angVel = rb0.getAngularVelocity();
						const fragment = debris[ j ];
						fragment.userData.velocity.set( vel.x(), vel.y(), vel.z() );
						fragment.userData.angularVelocity.set( angVel.x(), angVel.y(), angVel.z() );

						createDebrisFromBreakableObject( fragment );
					}
					objectsToRemove[ numObjectsToRemove ++ ] = threeObject0;
					userData0.collided = true;
				}

				if ( breakable1 && ! collided1 && maxImpulse > fractureImpulse ) {

					const debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal, 1, 2, 1.5 );

					const numObjects = debris.length;
					for ( let j = 0; j < numObjects; j ++ ) {
						const vel = rb1.getLinearVelocity();
						const angVel = rb1.getAngularVelocity();
						const fragment = debris[ j ];
						fragment.userData.velocity.set( vel.x(), vel.y(), vel.z() );
						fragment.userData.angularVelocity.set( angVel.x(), angVel.y(), angVel.z() );

						createDebrisFromBreakableObject( fragment );
					}
					objectsToRemove[ numObjectsToRemove ++ ] = threeObject1;
					userData1.collided = true;
				}
				
			}

			for ( let i = 0; i < numObjectsToRemove; i ++ )  removeDebris( objectsToRemove[ i ] );

			numObjectsToRemove = 0;
		}
		</script>
	</body>
</html>"$

	Return html
End Sub

' Taken from here and adapted: https://sbcode.net/threejs/physics-finger/#comments
Sub Scene2 As String
	
	Dim html As String = $"
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Finger physics</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Monospace;
      }
      .page-title {
        position: fixed;
        top: 0.75rem;
        left: 0;
        right: 0;
        text-align: center;
        color: white;
      }
      .page-title span { color: #99ff4e; }
    </style>
  </head>
  <body>
    <div class="page-title">Move the <span>mouse</span> to move the <span>balls and rotate, zoom, pan the scene</span></div>
	 	 
 	 <script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
    </script>
	 
    <script type="module">
 
	   import * as THREE from 'three'
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
		import Stats from 'three/addons/libs/stats.module.js'
		
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
		import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'
		
	   import * as CANNON from 'three/addons/physics/cannon-es.js'
		import CannonDebugger from 'three/addons/physics/cannon-es-debugger.js'

		const path = 'textures/cube/skybox/';
		const format = '.jpg';
		const envMap = new THREE.CubeTextureLoader().load([
			path + 'px' + format, path + 'nx' + format,
			path + 'py' + format, path + 'ny' + format,
			path + 'pz' + format, path + 'nz' + format,
		]);
		envMap.mapping = THREE.EquirectangunarReflectionMapping;
		envMap.encoding = THREE.sRGBEncoding;

		const scene = new THREE.Scene();
		//scene.background = new THREE.Color(0xcce0ff);
		scene.background = envMap;
		scene.environment = envMap;

		scene.fog = new THREE.Fog(0xcce0ff, 0.1, 300);

      const light1 = new THREE.SpotLight(0xffffff, 350)
      //light1.position.set(15, 15, -15)
		light1.position.set(-15, 15, 15)
      light1.angle = Math.PI / 4
      light1.penumbra = 0.5
      light1.castShadow = true
      light1.shadow.mapSize.width = 2048
      light1.shadow.mapSize.height = 2048
      light1.shadow.camera.near = 5
      light1.shadow.camera.far = 50
      light1.shadow.bias = 0.001
      scene.add(light1)

		scene.add( new THREE.SpotLightHelper( light1, 0xff00ff ) )

		scene.add( new THREE.AmbientLight( 0xffff00, 0.1 ) )

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
		camera.position.set(-5, 5, 5)

      const renderer = new THREE.WebGLRenderer()
      renderer.shadowMap.enabled = true
      renderer.setSize(window.innerWidth, window.innerHeight)
      document.body.appendChild(renderer.domElement)

      const controls = new OrbitControls(camera, renderer.domElement)
      controls.enableDamping = true

      const world = new CANNON.World()
      world.gravity.set(0, -9.81, 0)

      const material = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.05,
          metalness: 0.54,
          flatShading: true,
			 //transparent: true,
         //opacity: 0.9
      })
      const handMaterial = new THREE.MeshStandardMaterial({
          color: 0xff0000,
          roughness: 0.05,
          metalness: 0.54,
          //flatShading: true,
          transparent: true,
          opacity: 0.9,
      })
		
      const pmremGenerator = new THREE.PMREMGenerator(renderer)

		const envTexture = new THREE.TextureLoader().load('textures/equirectangular/equirectangular.png', () => {
          material.envMap = pmremGenerator.fromEquirectangular(envTexture).texture
			 
			 // My tests
			 //material.alphaMap = material.envMap
			 //material.lightMap = material.envMap
			 //material.side= THREE.DoubleSide
			 //material.envMapIntensity = 0.5
			 //material.transparency = true
			 //material.opacity = 0.5
			 //material.reflectivity = 4.0
      })

      let hand, bowl, fingerBody

      const gltfLoader = new GLTFLoader().load( 'models/gltf/right-hand-bent.glb', (gltf) => {
              hand = gltf.scene
              hand.children[0].position.set(0.95, 4, 0.85)
              hand.children[0].receiveShadow = true
              hand.children[0].castShadow = true
              hand.children[0].material = handMaterial
 
              scene.add(gltf.scene)

              fingerBody = new CANNON.Body({ mass: 0 })
              fingerBody.addShape(new CANNON.Sphere(0.25))
              fingerBody.addShape(new CANNON.Sphere(0.25), new CANNON.Vec3(0.05, 0.5, 0.1))
              fingerBody.addShape(new CANNON.Sphere(0.25), new CANNON.Vec3(0.1, 1.0, 0.2))
              fingerBody.position.set(0, 0, 0)
              world.addBody(fingerBody)

              const objLoader = new OBJLoader().load('models/obj/bowl2.obj', (obj) => {
                      bowl = obj.children[0]
                      bowl.receiveShadow = true
							 
                      //bowl.material = material			 
							 bowl.material = new THREE.MeshStandardMaterial({
					          color: 0x0000ff,
					          roughness: 0.35,
					          metalness: 0.2,
					          //flatShading: true,
					       })
							
                      scene.add(bowl)

                      // Using the raycaster to generate a cannon height field based on the loaded bowl geometry
                      const raycaster = new THREE.Raycaster()
                      const down = new THREE.Vector3(0, -1, 0)
                      const matrix = []
                      for (let x = -10; x <= 10; x++) {
                          matrix.push([])
                          for (let z = -10; z <= 10; z++) {
                              raycaster.set(new THREE.Vector3(x, 10, z), down)
                              const intersects = raycaster.intersectObject(bowl, false)
                              if (intersects.length > 0) {
                                  matrix[x + 10][z + 10] = intersects[0].point.y
                              } else {
                                  matrix[x + 10][z + 10] = 0
                              }
                          }
                      }

                      let bowlBody = new CANNON.Body({ mass: 0 })
                      var bowlShape = new CANNON.Heightfield(matrix)
                      bowlBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
                      bowlBody.addShape(bowlShape, new CANNON.Vec3())
                      bowlBody.position.x = -10
                      bowlBody.position.z = 10
                      world.addBody(bowlBody)

                      renderer.domElement.addEventListener('mousemove', onMouseMove, false)
                  },
                  (xhr) => { console.log((xhr.loaded / xhr.total) * 100 + '% loaded') },
                  (error) => { console.log(error) }
              )
          },
          (xhr) => { console.log((xhr.loaded / xhr.total) * 100 + '% loaded') },
          (error) => { console.log(error) }
      )

      const ballCount = 100
      const sphereMesh = new Array()
      const sphereBody = new Array()
		
      for (let i = 0; i < ballCount; i++) {
          const sphereGeometry = new THREE.SphereGeometry(0.5, 8, 8)
          sphereMesh.push(new THREE.Mesh(sphereGeometry, material))
          sphereMesh[i].position.x = Math.random() * 10 - 5
          sphereMesh[i].position.y = i / 4 + 4
          sphereMesh[i].position.z = Math.random() * 10 - 5
          sphereMesh[i].castShadow = true
          sphereMesh[i].receiveShadow = true
          scene.add(sphereMesh[i])
          
          const sphereShape = new CANNON.Sphere(0.5)
          sphereBody.push(new CANNON.Body({ mass: 0.1 }))
          sphereBody[i].addShape(sphereShape)
          sphereBody[i].position.x = sphereMesh[i].position.x
          sphereBody[i].position.y = sphereMesh[i].position.y
          sphereBody[i].position.z = sphereMesh[i].position.z
          world.addBody(sphereBody[i])
      }

      window.addEventListener('resize', onWindowResize, false)
      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight
          camera.updateProjectionMatrix()
          renderer.setSize(window.innerWidth, window.innerHeight)
          render()
      }

      const raycaster = new THREE.Raycaster()

      let fingerTo = new THREE.Vector3()

      function onMouseMove(event) {
          const mouse = {
              x: (event.clientX / renderer.domElement.clientWidth) * 2 - 1,
              y: -(event.clientY / renderer.domElement.clientHeight) * 2 + 1,
          }
          raycaster.setFromCamera(mouse, camera)
          const intersects = raycaster.intersectObject(bowl, false)
          if (intersects.length > 0)  fingerTo.copy(intersects[0].point)
      }

      const stats = new Stats()
      document.body.appendChild(stats.dom)

      const clock = new THREE.Clock()
      let delta

      const cannonDebugger = new CannonDebugger(scene, world)

      function animate() {
          requestAnimationFrame(animate)
          controls.update()

          delta = clock.getDelta()
          if (delta > 0.1) delta = 0.1
          world.step(delta)

          if (hand) {
              hand.position.copy(fingerTo)
              fingerBody.position.set(hand.position.x, hand.position.y + 0.66, hand.position.z)
              for (let i = 0; i < ballCount; i++) {
                  sphereMesh[i].position.set( sphereBody[i].position.x, sphereBody[i].position.y, sphereBody[i].position.z )
                  sphereMesh[i].quaternion.set( sphereBody[i].quaternion.x, sphereBody[i].quaternion.y, sphereBody[i].quaternion.z, sphereBody[i].quaternion.w )
              }
          }

          // Un-commment next line to see the cannon debug renderer shapes
          // cannonDebugger.update()

          render()
          stats.update()
      }

      function render() {
          renderer.render(scene, camera)
      }

      animate()	  
    </script>
  </body>
</html>
"$
	Return html
End Sub