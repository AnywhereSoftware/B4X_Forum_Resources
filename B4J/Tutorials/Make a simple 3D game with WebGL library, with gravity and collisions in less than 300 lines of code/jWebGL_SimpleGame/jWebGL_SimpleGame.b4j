AppType=JavaFX
Build1=Default,b4j.example
File1=Layout1.bjl
File2=skybox.zip
FileGroup1=Default Group
FileGroup2=Default Group
Group=Default Group
Library1=jcore
Library2=jfx
Library3=jxui
Library4=jwebgl
NumberOfFiles=2
NumberOfLibraries=4
NumberOfModules=0
Version=10
@EndOfDesignText@
#Region Project Attributes 
	#MainFormWidth: 300
	#MainFormHeight: 200 
#End Region

' This demo show you how simple is creating a simple base 3D game with physic engine, gravity and collisions and
' keyboard control with just a bit more than 200 lines of javascript code without use any physic engine libraries.
'
' This demo code is not mine, it is taken from this tutorial: https://www.youtube.com/watch?v=sPereCgQnWQ
' I advice you to follow the good video tutorial that explain this code line by line.
'
' Focus of this demo project:
'
' - Show how to get threejs directly from CDN repositories (on the web) without having threejs distribution locally. 
'   The only limit here is that you will need an internet connection.
'   You can even set the release to use, eg. on this code we use threejs 172.0, the latest at this moment.
' - Show how to extend classes and customize for our needs
' - Show how to use keyboard to control anything in the scene
' - Show how to create gravity and collisions by code without use physics libraries
' - Show how it is simple integrate on B4X WebGL, projects written in pure javascript form other users and taken from the web,
'   adapt it just required me about 15 minutes to get it working, then some time to some make modifications for my needs.
'
' NOTE: I changed it a bit from original tutorial. 
'       To know what I changed, I leaved all my changes in the JavaScript code without tabulation (on the left margin).

Sub Process_Globals
	Private fx As JFX
	Private MainForm As Form
	Private xui As XUI	
	Private Button1 As B4XView
	Private gl As WebGL
	Private Port As Int = 8888
End Sub

Sub AppStart (Form1 As Form, Args() As String)
	MainForm = Form1
	MainForm.RootPane.LoadLayout("Layout1")
	MainForm.Title = "WebGL Simple Game"
	MainForm.Show
End Sub

Sub Button1_Click
	Button1.Enabled = False
	
	' Set here the path where THREEJS distribution was unzipped.
	' More concurrent projects can run at same time, just use different port for each.
	gl.Initialize(Me, "WebGL", "WebGL_SimpleGame", "GMT+1", File.DirData("B4XWebGL"), Port)
	
	Wait For (gl.CopyResourcesFromZipFileToSingleFolder("textures/cube/skybox", "skybox.zip", 8192)) Complete (Success As Boolean)
	If Success Then
		LogColor("SKY TEXTURES DONE", xui.Color_Blue)
	Else
		LogColor("SOMETHING WENT WRONG WHILE GET SKY TEXTURES", xui.Color_Red)
	End If
	
	Wait For (gl.GetEngine) Complete (Success As Boolean)
	If Success Then
'		gl.SetLocalServer
		gl.StartEngine3(GameTest)
		gl.Update
	Else
		LogError("Unable to initialize WebGL Library")
	End If
End Sub

'///////////// WebGL Library Events ////////////

' Called if error occours
Sub WebGL_Error(Error As String)
	LogColor(Error, xui.Color_Red)
End Sub

 ' IMPORTANT NOTE: _ReadyToCode event is never fired when we use GetEngine3 and pass a full html string.
 '                 When we load a full HTML + JS code, we cannot use Inject command or other similar commands
 '                 that inject code. Your final code will be contained in the passed full HTML string.

' Called just one time when the scene is updated
Private Sub WebGL_Updated(Url As String)
	Log(" ") : Log("Server static folder: " & gl.MainFolder)
	Log(" ") : Log("To access the scene:")
	LogColor(Url, xui.Color_Magenta)
	Log("To access the library main page:")
	LogColor(gl.ServerMainPage, xui.Color_Magenta) : Log(" ")
	
'	' To avoid log truncation we can print it line by line
'	Dim lines() As String = Regex.Split(CRLF, gl.HtmlStringDebug)
'	For Each line As String In lines
'		LogColor(line, xui.Color_Blue)
'	Next
	
'	LogColor(gl.HtmlString, xui.Color_Green) : Log(" ")  ' Show the final html string
'	LogColor(gl.HtmlStringDebug, xui.Color_Green) : Log(" ")  ' Show the final html string in debug mode with line numbers. With this you can track JavaScript console errors.
End Sub

' Called when there are library server logs
Private Sub WebGL_ServerLog(Text As String)
	If Text.Contains(".html") Or Text.ToLowerCase.Contains("mainpage") Then
		If Text.Contains("[200]") Then  ' File found
			LogColor(Text, xui.Color_Magenta)
		Else If Text.Contains("[304]") Then  ' Cached
			LogColor(Text, 0xFFFF7F00)
		Else If Text.Contains("[404]") Then  ' File not found
			LogColor(Text, xui.Color_Red)
		End If
	Else
		If Text.Contains("[200]") Then  ' File found
			LogColor(Text, xui.Color_Blue)
		Else If Text.Contains("[304]") Then  ' Cached
			LogColor(Text, 0xFFFF7F00)
		Else If Text.Contains("[404]") Then  ' File not found
			LogColor(Text, xui.Color_Red)
		End If
	End If
End Sub

'/////////////////////////// GAME SCENE ///////////////////////////////

'NOTE: I outdented my code modifications from original tutorial.

Sub GameTest As String
	
	Dim html As String = $"<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - Simple game developed on B4X</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				padding: 0;
	         margin: 0;
	         overflow: hidden;
			}						
			#info {
				position: absolute;
				top: 0;
				width: 100%;
				color: black;
				text-align: center;
				padding: 5px 0;
			}
			#output {
				padding: 5px;
				bottom: 0;
				left: 0;
				opacity: 0.5;
				position: absolute;
				color: white;
				text-align: center;
				font-size: 2em;
			}
		</style>
	</head>
	<body>	
      <center>
		   <div id="info">
				B4X WebGL - Simple game<br>Use WASD to move and SPACE to jump.<br>Try to avoid cubes, the more you stay on blue ground, the more you collect points.<br>You can jump more times but when you jump you do not collect points.<br>
				When you collide with other cubes you reached the GAME OVER.<br>You can find the video tutorial for this code. Many thanks to the author.<br>I made some changes but started from here: <a href="https://www.youtube.com/watch?v=sPereCgQnWQ/" target="_blank" rel="noopener">VideoTutorial</a>
			</div>
		</center>
		
		<div id="output"></div>	

		<script type="importmap">
		  {
		    "imports": {
		      "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
		      "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
		    }
		  }
		</script>
		
		<script type="module">
			import * as THREE from 'three'
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
			import Stats from 'three/addons/libs/stats.module.js'
			
const stats = new Stats();
document.body.appendChild(stats.dom);
			
			const scene = new THREE.Scene()

const path = 'textures/cube/skybox/'
const format = '.jpg'
const envMap = new THREE.CubeTextureLoader().load([
	path + 'px' + format, path + 'nx' + format,
	path + 'py' + format, path + 'ny' + format,
	path + 'pz' + format, path + 'nz' + format,
])
envMap.mapping = THREE.EquirectangunarReflectionMapping
envMap.encoding = THREE.sRGBEncoding

scene.background = envMap;
scene.environment = envMap;
	 
scene.fog = new THREE.Fog(0xFFCC66, 10, 150);

let output = document.getElementById( 'output' );
output.innerText = 'Welcome to Cube Game'

			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
			//camera.position.set(4.61, 2.74, 8)
camera.position.set(0, 2.8, 24)

			const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true })
			renderer.shadowMap.enabled = true
			renderer.setSize(window.innerWidth, window.innerHeight)
			document.body.appendChild(renderer.domElement)

			const controls = new OrbitControls(camera, renderer.domElement)
controls.rotateSpeed = 1.2;    // By default 1.0
controls.zoomSpeed = 1.4;      // By default 1.0
controls.panSpeed = 1.4;       // By default 1.0
controls.enableDamping = true; // By default false
controls.dampingFactor = 0.05; // By default 0.05
			
			class Box extends THREE.Mesh {  // We made a simple class to simplify the work
				constructor({
					width,
					height,
					depth,
					color = '#00ff00',
					velocity = { x: 0, y: 0, z: 0 },
					position = { x: 0, y: 0, z: 0 },
					zAcceleration = false
				}) {
				
const mat = new THREE.MeshStandardMaterial({ color })
mat.roughness = 0.65
mat.metalness = 0.2

            super(new THREE.BoxGeometry(width, height, depth), mat)
			      this.width = width
			      this.height = height
			      this.depth = depth

			      this.position.set(position.x, position.y, position.z)

			      this.right = this.position.x + this.width / 2
			      this.left = this.position.x - this.width / 2
			      this.bottom = this.position.y - this.height / 2
			      this.top = this.position.y + this.height / 2
			      this.front = this.position.z + this.depth / 2
			      this.back = this.position.z - this.depth / 2
					
			      this.velocity = velocity
			      this.gravity = -0.002  // Try to change here the gravity. Use small values.
			      this.zAcceleration = zAcceleration
				}

				updateSides() {
					this.right = this.position.x + this.width / 2
					this.left = this.position.x - this.width / 2
					this.bottom = this.position.y - this.height / 2
					this.top = this.position.y + this.height / 2
					this.front = this.position.z + this.depth / 2
					this.back = this.position.z - this.depth / 2
				}

				update(ground) {
			      this.updateSides()
			      if (this.zAcceleration) this.velocity.z += 0.0003
			      this.position.x += this.velocity.x
			      this.position.z += this.velocity.z
			      this.applyGravity(ground)
				}

				applyGravity(ground) {
			      this.velocity.y += this.gravity	     		   
					if ( boxCollision({ box1: this, box2: ground }) ) {   // This is where we hit the ground
			        const friction = 0.58
			        this.velocity.y *= friction
			        this.velocity.y = -this.velocity.y
			      } else this.position.y += this.velocity.y
				}		 
			}

			function boxCollision({ box1, box2 }) {
				const xCollision = box1.right >= box2.left && box1.left <= box2.right
				const yCollision = box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
				const zCollision = box1.front >= box2.back && box1.back <= box2.front
				return xCollision && yCollision && zCollision
			}

			const cube = new Box({ width: 1, height: 1, depth: 1, velocity: { x: 0, y: -0.01, z: 0 }, position: { x: 0, y: 3, z: 20 } })
			cube.castShadow = true
			scene.add(cube)

			const ground = new Box({ width: 10, height: 0.5, depth: 50, color: '#0369a1', position: { x: 0, y: -0.25, z: 0 } })
			ground.receiveShadow = true
			scene.add(ground)

			const light = new THREE.DirectionalLight(0xffffff, 3)
			light.position.set(-20, 13, 19) // Point to the sun. To get it in the scene, uncomment the line for CameraHelper
			light.castShadow = true
			
 const d = 30;
 light.shadow.camera.left = -d;
 light.shadow.camera.right = d;
 light.shadow.camera.top = d;
 light.shadow.camera.bottom = -d;

 light.shadow.mapSize.width = 2048;
 light.shadow.mapSize.height = 2048;
 light.shadow.camera.near = 1;
 light.shadow.camera.far = 60;
 //light.shadow.bias = -0.0022;
			
			scene.add(light)
 //scene.add(new THREE.CameraHelper(light.shadow.camera));

			scene.add(new THREE.AmbientLight(0xffffff, 1))

			console.log(ground.top)
			console.log(cube.bottom)

			const keys = { a: {pressed: false}, d: {pressed: false}, s: {pressed: false}, w: {pressed: false} }

			window.addEventListener('keydown', (event) => {
				switch (event.code) {
					case 'KeyA':
						keys.a.pressed = true
						break
					case 'KeyD':
						keys.d.pressed = true
						break
					case 'KeyS':
						keys.s.pressed = true
						break
					case 'KeyW':
						keys.w.pressed = true
						break
					case 'Space':
						cube.velocity.y = 0.08
						break
				}
			})

			window.addEventListener('keyup', (event) => {
				switch (event.code) {
					case 'KeyA':
						keys.a.pressed = false
						break
					case 'KeyD':
						keys.d.pressed = false
						break
					case 'KeyS':
						keys.s.pressed = false
						break
					case 'KeyW':
						keys.w.pressed = false
						break
				}
			})
			
			window.addEventListener('resize', onWindowResize, false);
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				animate();
			}

			const enemies = []
			let frames = 0, spawnRate = 200, cubeSpeed = 0.065, points = 0
			
			function animate() {  // Animation loop
				const animationId = requestAnimationFrame(animate)  // Request the animation loop
				renderer.render(scene, camera)
	
stats.update();     // Update stats	
controls.update();     // Update OrbitControls
				
				// Movement code
				cube.velocity.x = 0
				cube.velocity.z = 0
				if (keys.a.pressed) cube.velocity.x = -cubeSpeed
				else if (keys.d.pressed) cube.velocity.x = cubeSpeed
				if (keys.s.pressed) cube.velocity.z = cubeSpeed
				else if (keys.w.pressed) cube.velocity.z = -cubeSpeed

				cube.update(ground)
				enemies.forEach((enemy) => { 
				   enemy.update(ground)
					if ( boxCollision({ box1: cube, box2: enemy }) ) { // Get collisions			
						setTimeout(function () {
							output.innerText = 'GAME OVER.\nFinal Points: ' + points
							console.log('Collided. Refresh the page to restart.')
							cancelAnimationFrame(animationId)  // Cancel the animation loop
							alert('GAME OVER\n\nFinal Points: ' + points + '\n\nRefresh the page to restart.')						
						}, 10);					
					}
				})
			 
if (parseFloat(cube.bottom.toFixed(1)) === parseFloat(ground.top.toFixed(1))) { // Increment points when the cube touch the blue ground (while no jump)
	points++;
	output.innerText = 'Points: ' + points
}
				if (frames % spawnRate === 0) {
					if (spawnRate > 20) spawnRate -= 20
					const enemy = new Box({ width: 1, height: 1, depth: 1,
						position: { x: (Math.random() - 0.5) * 10, y: 10, z: -20 },
						velocity: { x: 0, y: 0, z: 0.005 },
						color:  new THREE.Color(Math.floor(Math.random() * 16777216)),    //'red',
						zAcceleration: true
					})
					enemy.castShadow = true
					scene.add(enemy)
					enemies.push(enemy)
				}
				
				frames++
			}
					
			animate()  // Request the animation loop
		</script>
	</body>
</html>"$

	Return html
End Sub
