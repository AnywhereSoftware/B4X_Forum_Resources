AppType=JavaFX
Build1=Default,b4j.example
File1=Layout1.bjl
File2=Resources.zip
FileGroup1=Default Group
FileGroup2=Default Group
Group=Default Group
Library1=jcore
Library2=jfx
Library3=jwebgl
Library4=jxui
NumberOfFiles=2
NumberOfLibraries=4
NumberOfModules=0
Version=10
@EndOfDesignText@
#Region Project Attributes 
	#MainFormWidth: 300
	#MainFormHeight: 200 
#End Region

Sub Process_Globals
	Private fx As JFX
	Private MainForm As Form
	Private xui As XUI
	Private Button1 As B4XView
	
	Private gl As WebGL
	Private Port As Int = 8888
End Sub

Sub AppStart (Form1 As Form, Args() As String)
	MainForm = Form1
	MainForm.RootPane.LoadLayout("Layout1")
	MainForm.Title = "WebGL Physics Engines"
	MainForm.Show
End Sub

Sub Button1_Click
	Button1.Enabled = False
	
	' Set here the path where THREEJS distribution was unzipped.
	' More concurrent projects can run at same time, just use different port for each if you need this.
	gl.Initialize(Me, "WebGL", "WebGL_Physics_Engines", "GMT+1", File.DirData("B4XWebGL"), Port)

	Dim files As List
	files.Initialize										  									  
	files.AddAll(Array As String( "jsm/physics/cannon-es.js", _
	                              "jsm/physics/cannon-es-debugger.js", _
											"jsm/physics/PointerLockControlsCannon.js", _
											"textures/hardwood2_diffuse.jpg", _
											"textures/hardwood2_bump.jpg", _
											"textures/hardwood2_roughness.jpg", _
											"textures/patterns/B4J.jpg", _										
											"textures/patterns/B4J-NormalMap.jpg", _						
											"textures/football.jpeg"))
											 									  									  									  
	Wait For (gl.CopyResourcesFromZipFile(files, "Resources.zip", 8192)) Complete (Success As Boolean)
	If Success Then
		LogColor("RESOURCES DONE", xui.Color_Blue)
	Else
		LogColor("SOMETHING WENT WRONG WHILE GET RESOURCES", xui.Color_Red)
		ExitApplication
	End If

	'''''''''''''
	
	Wait For (gl.GetEngine) Complete (Success As Boolean)
	If Success Then
'		gl.SetLocalServer(True)
		gl.StartEngine3(Scene)
		gl.Update
	Else
		LogError("Unable to initialize WebGL Library")
	End If
End Sub

'///////////// WebGL Library Events ////////////

' Called if error occours
Sub WebGL_Error(Error As String)
	LogColor(Error, xui.Color_Red)
End Sub

 ' IMPORTANT NOTE: _ReadyToCode event is never fired when we use StartEngine3 and pass a full html string.
 '                 When we load a full HTML + JS code, we cannot use Inject command or other similar commands
 '                 that inject code. Your final code is all contained in the passed full HTML string.

' Called just one time when the scene is updated
Private Sub WebGL_Updated(Url As String)
	Log(" ") : LogColor("Server static folder: " & gl.MainFolder, xui.Color_Magenta)
	Log(" ") : Log("To access the scene:")
	LogColor(Url, xui.Color_Magenta)
	Log("To access the library main page:")
	LogColor(gl.ServerMainPage, xui.Color_Magenta) : Log(" ")
	
' ' To avoid log truncation we can print it line by line
'	Dim lines() As String = Regex.Split(CRLF, gl.HtmlStringDebug)
'	For Each line As String In lines
'		LogColor(line, xui.Color_Blue)
'	Next
	
'	LogColor(gl.HtmlString, xui.Color_Blue) : Log(" ")  ' Show the final html string
'	LogColor(gl.HtmlStringDebug, xui.Color_Blue) : Log(" ")  ' Show the final html string in debug mode with line numbers. With this we can track JavaScript console errors.
End Sub

' Called when there are library server logs
Private Sub WebGL_ServerLog(Text As String)
	If Text.Contains(".html") Or Text.ToLowerCase.Contains("mainpage") Then
		If Text.Contains("[200]") Then  ' File found
			LogColor(Text, xui.Color_Magenta)
		Else If Text.Contains("[304]") Then  ' Cached
			LogColor(Text, 0xFFFF7F00)
		Else If Text.Contains("[404]") Then  ' File not found
			LogColor(Text, xui.Color_Red)
		End If
	Else
		If Text.Contains("[200]") Then  ' File found
			LogColor(Text, xui.Color_Blue)
		Else If Text.Contains("[304]") Then  ' Cached
			LogColor(Text, 0xFFFF7F00)
		Else If Text.Contains("[404]") Then  ' File not found
			LogColor(Text, xui.Color_Red)
		End If
	End If
End Sub

'/////////////////////////// SCENE ///////////////////////////////

Sub Scene As String
	
	Dim html As String = $"<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>B4X WebGL + cannon.js + three.js - physics shooter</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <style>
		body {
			font-family: Monospace;
			background-color: black;
			color: white;
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}
		.dot {
		  position: absolute;
		  top: 50%;
		  left: 50%;
		  width: 10px;
		  height: 10px;
		  border-radius: 50%;
		  transform: translate3d(-50%, -50%, 0);
		  border: 1px solid white;
		}
		#info {
			top: 0;
			width: 100%;
			color: lightgray;
			font-family: monospace;
			text-align: center;
			padding: 5px 0;
		}
      #instructions {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.5);
        color: #ffffff;
        text-align: center;
        cursor: pointer;
      }
      #instructions span {
        font-size: 36px;
		  color: blue;
      }
    </style>

  </head>
  <body>
		<div id="info">B4X WebGL + cannon.js + three.js - physics shooter<br/>Press ESC to get mouse pointer.</div>
		
      <div class="dot"></div>  <!-- The pointer -->
  
		<div id="instructions">
			<span><b>Click to play</b></span><br/>(W,A,S,D or ARROWS = Move, SPACE = Jump, MOUSE = Look, CLICK = Shoot)<br/>Press ESC to get mouse pointer.
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">
		
	 	import * as THREE from 'three'
      import Stats from 'three/addons/libs/stats.module.js'
		   
		import * as CANNON from 'three/addons/physics/cannon-es.js'
		//import CannonDebugger from 'three/addons/physics/cannon-es-debugger.js'
		
	   import { PointerLockControlsCannon } from 'three/addons/physics/PointerLockControlsCannon.js'					 	  			
		
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		
      /**
       * Example of a really barebones version of a fps game.
       */

      // three.js variables
      let camera, scene, renderer, gui, stats, boxMat, floorMat, cubeTexture

      // cannon.js variables
      let world
      let controls
      const timeStep = 1 / 60
      let lastCallTime = performance.now()
      let sphereShape, sphereBody, physicsMaterial
      const balls = []
      const ballMeshes = []
      const boxes = []
      const boxMeshes = []
		
		let adaptiveBallForce = false
		let mouseTime = 0
		var gravity = 9.81
      let shootVelocity = 15	
		
      const cubeCount = 10
		let ballRadius = 0.2
		
		const textureLoader = new THREE.TextureLoader();
			
      const instructions = document.getElementById('instructions')
		const info = document.getElementById('info')

		//////// MAIN ////////

      initThree()	
      initCannon()
      initPointerLock()
		    
      animate()
		
		/////////////////////

      function initThree() {
			// Camera
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100)

			// Scene
			scene = new THREE.Scene()
			scene.fog = new THREE.Fog(0x000000, 0, 100)

			// Renderer
			renderer = new THREE.WebGLRenderer({ antialias: true })
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight)
			renderer.setClearColor(scene.fog.color)
			renderer.outputEncoding = THREE.sRGBEncoding;
			//renderer.toneMapping = THREE.NeutralToneMapping;
			//renderer.toneMappingExposure = 1.1;

         // Shadows
			renderer.shadowMap.enabled = true

			//renderer.shadowMap.type = THREE.BasicShadowMap;    // Gives unfiltered shadow maps - fastest, but lowest quality.
			//renderer.shadowMap.type = THREE.PCFShadowMap;      // Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm (default)
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with better soft shadows especially when using low-resolution shadow maps
			//renderer.shadowMap.type = THREE.VSMShadowMap;	     // Filters shadow maps using the Variance Shadow Map (VSM) algorithm. When using VSMShadowMap all shadow receivers will also cast shadows
					
			document.body.appendChild(renderer.domElement)

			// Stats.js
			stats = new Stats()
			document.body.appendChild(stats.dom)

			gui = new GUI()  // Our GUI interface
		  				
			gui.add({Gravity: gravity}, 'Gravity', -1, 30, 0.1).onChange( (value) => { 
				gravity = value 
				world.gravity.set(0, -gravity, 0)  // <<<<<<<<< Gravity
			})
 			
			const params = {AdaptiveForce: adaptiveBallForce, vel: shootVelocity, radius: ballRadius}; // Set it to initial adaptiveBallForce
			gui.add(params, 'AdaptiveForce').name('Adaptive ball speed').onChange( (value) => { 
				adaptiveBallForce = value; 
			}) 
			gui.add(params, 'vel', 0, 50, 1).name('Ball speed').onChange( (value) => {
				console.log("Ball speed:  ", value)
				shootVelocity = value
			})
		  	gui.add(params, 'radius', 0.1, 2.0, 0.1).name('Ball radius').onChange( (value) => {
				console.log("Ball radius:  ", value)
				ballRadius = value
			})
			
			// Lights
			const ambientLight = new THREE.AmbientLight(0xffffff, 0.1)
			scene.add(ambientLight)

			// color - (optional) hexadecimal color of the light. Default is 0xffffff (white).
			// intensity - (optional) numeric value of the light's strength/intensity. Default is 1.
			// distance - Maximum range of the light. Default is 0 (no limit).
			// angle - Maximum angle of light dispersion from its direction whose upper bound is Math.PI/2.
			// penumbra - Percent of the spotlight cone that is attenuated due to penumbra. Takes values between zero and 1. Default is zero.
			// decay - The amount the light dims along the distance of the light.

			const spotLight = new THREE.SpotLight( 0xffffff, 1800, 0, Math.PI / 4, 0.5 )
			spotLight.position.set(10, 10, -20)
			spotLight.target.position.set(0, 0, 0)
			//spotLight.map = new THREE.TextureLoader().load( ur

			spotLight.castShadow = true

			//spotLight.shadow.bias = -0.0001
			spotLight.shadow.mapSize.width = 4096
			spotLight.shadow.mapSize.height = 4096

			spotLight.shadow.camera.near = 10
			spotLight.shadow.camera.far = 160
			spotLight.shadow.camera.fov = 30

			scene.add( spotLight )

			const spotLightHelper = new THREE.SpotLightHelper( spotLight )
			scene.add( spotLightHelper )

			// Boxes

			// Generic material

			//cubeTexture = new THREE.TextureLoader().load( 'textures/crate.gif' );	
			cubeTexture = new THREE.TextureLoader().load( 'textures/patterns/B4J.jpg' )
			//cubeTexture = new THREE.TextureLoader().load( 'textures/brick_diffuse.jpg' )	
			
			cubeTexture.anisotropy = renderer.capabilities.getMaxAnisotropy()
			cubeTexture.colorSpace = THREE.SRGBColorSpace
	 
			boxMat = new THREE.MeshLambertMaterial({   // new THREE.MeshPhongMaterial({ 
				map: cubeTexture,
				bumpScale: 1  
			})
					
			textureLoader.load( 'textures/patterns/B4J-NormalMap.jpg', function ( map ) {
			//textureLoader.load( 'textures/brick_bump.jpg', function ( map ) {
				map.wrapS = THREE.RepeatWrapping
				map.wrapT = THREE.RepeatWrapping
				map.anisotropy = renderer.capabilities.getMaxAnisotropy()
				map.repeat.set( 1, 1 )
				boxMat.bumpMap = map
				boxMat.needsUpdate = true
			})
			gui.add(boxMat, 'bumpScale', 0, 10, 0.01).name('Boxes bump')
				 		 
			// Floor
		  
			floorMat = new THREE.MeshStandardMaterial( {
				roughness: 0.8,
				color: 0xffffff,
				metalness: 0.2,
				bumpScale: 1
			})

			textureLoader.load( 'textures/hardwood2_diffuse.jpg', function ( map ) {
				map.wrapS = THREE.RepeatWrapping
				map.wrapT = THREE.RepeatWrapping
				map.anisotropy = 4
				map.repeat.set( 40, 96 )
				map.colorSpace = THREE.SRGBColorSpace
				floorMat.map = map
				floorMat.needsUpdate = true
			} );
			textureLoader.load( 'textures/hardwood2_bump.jpg', function ( map ) {
				map.wrapS = THREE.RepeatWrapping
				map.wrapT = THREE.RepeatWrapping
				map.anisotropy = 4
				map.repeat.set( 40, 96 )
				floorMat.bumpMap = map
				floorMat.needsUpdate = true
			} );
			textureLoader.load( 'textures/hardwood2_roughness.jpg', function ( map ) {
				map.wrapS = THREE.RepeatWrapping
				map.wrapT = THREE.RepeatWrapping
				map.anisotropy = 4
				map.repeat.set( 40, 96 )
				floorMat.roughnessMap = map
				floorMat.needsUpdate = true
			} );  
		  	  
			const floorGeometry = new THREE.PlaneGeometry(300, 300, 100, 100)
			floorGeometry.rotateX(-Math.PI / 2)
			//const floorMesh = new THREE.Mesh(floorGeometry, new THREE.MeshPhongMaterial({ color: 0x0000ff }))
			const floorMesh = new THREE.Mesh(floorGeometry, floorMat)
			floorMesh.receiveShadow = true
			scene.add(floorMesh)

			window.addEventListener('resize', onWindowResize)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function initCannon() {
        world = new CANNON.World()

        // Tweak contact properties.
        // Contact stiffness - use to make softer/harder contacts
        world.defaultContactMaterial.contactEquationStiffness = 1e9

        // Stabilization time in number of timesteps
        world.defaultContactMaterial.contactEquationRelaxation = 4

        const solver = new CANNON.GSSolver()
        solver.iterations = 7
        solver.tolerance = 0.1
        world.solver = new CANNON.SplitSolver(solver)
        // world.solver = solver       // Use this to test non-split solver

        world.gravity.set(0, -gravity, 0)  // <<<<<<<<< Gravity

        // Create a slippery material (friction coefficient = 0.0)
        physicsMaterial = new CANNON.Material('physics')
        const physics_physics = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
          friction: 0.0,
          restitution: 0.3,
        })
 
        world.addContactMaterial(physics_physics)    // We must add the contact materials to the world

        // Create the user collision sphere
        const radius = 1.3
        sphereShape = new CANNON.Sphere(radius)
        sphereBody = new CANNON.Body({ mass: 5, material: physicsMaterial })
        sphereBody.addShape(sphereShape)
        sphereBody.position.set(0, 5, 0)
        sphereBody.linearDamping = 0.9
        world.addBody(sphereBody)

        // Create the ground plane
        const groundShape = new CANNON.Plane()
        const groundBody = new CANNON.Body({ mass: 0, material: physicsMaterial })
        groundBody.addShape(groundShape)
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
        world.addBody(groundBody)

        // Add boxes both in cannon.js and three.js
        const halfExtents = new CANNON.Vec3(1, 1, 1)
        const boxShape = new CANNON.Box(halfExtents)
		  const boxGeometry = new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2)

        for (let i = 0; i < cubeCount; i++) {
          const boxBody = new CANNON.Body({ mass: 5 })
          boxBody.addShape(boxShape)
          const boxMesh = new THREE.Mesh(boxGeometry, boxMat)

          const x = (Math.random() - 0.5) * 20
			 const y = Math.random() * 100 + 5
          const z = (Math.random() - 0.5) * 20

          boxBody.position.set(x, y, z)
          boxMesh.position.copy(boxBody.position)

          boxMesh.castShadow = true
          boxMesh.receiveShadow = true

          world.addBody(boxBody)
          scene.add(boxMesh)
          boxes.push(boxBody)
          boxMeshes.push(boxMesh)
        }

        // Add linked boxes
        const size = 0.5
        const mass = 1.0
        const space = 0.1 * size
        const N = 8
        const halfExtents2 = new CANNON.Vec3(size, size, size * 0.1)
        const boxShape2 = new CANNON.Box(halfExtents2)
        const boxGeometry2 = new THREE.BoxGeometry(halfExtents2.x * 2, halfExtents2.y * 2, halfExtents2.z * 2)
 
        let last
        for (let i = 0; i < N; i++) {
          // Make the fist one static to support the others
          const boxBody = new CANNON.Body({ mass: i === 0 ? 0 : mass })
          boxBody.addShape(boxShape2)
          const boxMesh = new THREE.Mesh(boxGeometry2, boxMat)
          boxBody.position.set(5, (N - i) * (size * 2 + 2 * space) + size * 2 + space, 0)
          boxBody.linearDamping = 0.01
          boxBody.angularDamping = 0.01

          boxMesh.castShadow = true
          boxMesh.receiveShadow = true

          world.addBody(boxBody)
          scene.add(boxMesh)
          boxes.push(boxBody)
          boxMeshes.push(boxMesh)

          if (i > 0) {
            // Connect the body to the last one
            const constraint1 = new CANNON.PointToPointConstraint(
              boxBody,
              new CANNON.Vec3(-size, size + space, 0),
              last,
              new CANNON.Vec3(-size, -size - space, 0)
            )
            const constranit2 = new CANNON.PointToPointConstraint(
              boxBody,
              new CANNON.Vec3(size, size + space, 0),
              last,
              new CANNON.Vec3(size, -size - space, 0)
            )
            world.addConstraint(constraint1)
            world.addConstraint(constranit2)
          }

          last = boxBody
        }

			// The shooting balls
			
			// Use this if you do not need to change the balls radius. Remember to uncomment the same code below in 'mouseup' event.
			// This way you instance a single ball geometry for all balls, instead of create new ones every ball tat will consume more memory and graphics resources.
			//	const ballShape = new CANNON.Sphere(ballRadius)
			// const ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32)

			// Returns a vector pointing the direction the camera is at
			function getShootDirection() {
				const vector = new THREE.Vector3(0, 0, 1)
				vector.unproject(camera)
				const ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize())
				return ray.direction
			}

			const ballTexture = textureLoader.load( 'textures/football.jpeg', function ( map ) {
				map.wrapS = THREE.RepeatWrapping;
				map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 4;
				map.repeat.set( 1, 1 );
				map.colorSpace = THREE.SRGBColorSpace;
			})

			const ballMat = new THREE.MeshLambertMaterial({	
				map: ballTexture,
				bumpMap: ballTexture,
				bumpScale: 4  
			})
			ballMat.needsUpdate = true;
			gui.add(ballMat, 'bumpScale', 0, 10, 0.01).name('Balls bump');

		   window.addEventListener( 'mousedown', (evt) => {			
				if (!controls.enabled) return
				
				if (evt.button === 0) {
					mouseTime = performance.now(); // Start sampling time if adaptive ball force is used (it looks like DateTime.Time(now) in B4X)
				} else if (evt.button === 2) {
					 // Jump
				}	
			});
		
			window.addEventListener( 'mouseup', (evt) => {
				if (!controls.enabled) return
				
				if (evt.button === 0) {	
					const ballShape = new CANNON.Sphere(ballRadius)
			      const ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32)
					
				   const ballBody = new CANNON.Body({ mass: 2 })
					ballBody.addShape(ballShape)
					//  const ballMesh = new THREE.Mesh(ballGeometry, new THREE.MeshPhongMaterial( { color: 0xff0000, shininess: 400 } )) // Red ball
										
					const ballMesh = new THREE.Mesh(ballGeometry, ballMat)

					ballMesh.castShadow = true
					ballMesh.receiveShadow = true

					world.addBody(ballBody)
					scene.add(ballMesh)
					balls.push(ballBody)
					ballMeshes.push(ballMesh)

					const shootDirection = getShootDirection()
									
					if (adaptiveBallForce) {
						const elapsed = performance.now() - mouseTime
						shootVelocity =  elapsed * 0.05
						//console.log('Elapsed Time (ms): ' + elapsed + '   shootVelocity: ' + shootVelocity)
						info.innerHTML = 'Adaptive shot velocity: ' + shootVelocity + '   Elapsed Time (ms): ' + elapsed
					}
						
					ballBody.velocity.set( shootDirection.x * shootVelocity, shootDirection.y * shootVelocity, shootDirection.z * shootVelocity )

					// Move the ball outside the player sphere
					const x = sphereBody.position.x + shootDirection.x * (sphereShape.radius * 1.01 + ballShape.radius)
					const y = sphereBody.position.y + shootDirection.y * (sphereShape.radius * 1.01 + ballShape.radius)
					const z = sphereBody.position.z + shootDirection.z * (sphereShape.radius * 1.01 + ballShape.radius)			
					
					ballBody.position.set(x, y, z)
					ballMesh.position.copy(ballBody.position)
				}	
			});			  				
      }

      function initPointerLock() {
        controls = new PointerLockControlsCannon(camera, sphereBody)
        scene.add(controls.getObject())

        instructions.addEventListener('click', () => {
          controls.lock()
        })

        controls.addEventListener('lock', () => {
          controls.enabled = true
          instructions.style.display = 'none'
        })

        controls.addEventListener('unlock', () => {
          controls.enabled = false
          instructions.style.display = null
        })
      }

      function animate() {
			requestAnimationFrame(animate)

			const time = performance.now() / 1000
			const dt = time - lastCallTime
			lastCallTime = time

			if (controls.enabled) {
				world.step(timeStep, dt)

				// Update ball positions
				for (let i = 0; i < balls.length; i++) {
					ballMeshes[i].position.copy(balls[i].position)
					ballMeshes[i].quaternion.copy(balls[i].quaternion)
				}

				// Update box positions
				for (let i = 0; i < boxes.length; i++) {
					boxMeshes[i].position.copy(boxes[i].position)
					boxMeshes[i].quaternion.copy(boxes[i].quaternion)
				}
			}

			controls.update(dt)  

			renderer.render(scene, camera)
			stats.update()
      }
    </script>
  </body>
</html> 
"$

	Return html
End Sub